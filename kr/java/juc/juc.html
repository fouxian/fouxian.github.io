<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JUC | Keep Running</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/favicon.png">
    <script charset="utf-8" async="async" src="/js/jquery.min.js"></script>
    <script charset="utf-8" async="async" src="/js/global.js"></script>
    <script charset="utf-8" async="async" src="/js/fingerprint2.min.js"></script>
    <meta name="description" content="">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    
    <link rel="preload" href="/assets/css/0.styles.42b858ce.css" as="style"><link rel="preload" href="/assets/js/app.cfd60917.js" as="script"><link rel="preload" href="/assets/js/4.8234885e.js" as="script"><link rel="preload" href="/assets/js/3.1429892b.js" as="script"><link rel="preload" href="/assets/js/43.f867a280.js" as="script"><link rel="prefetch" href="/assets/js/10.0f0de338.js"><link rel="prefetch" href="/assets/js/11.0c47d372.js"><link rel="prefetch" href="/assets/js/12.b45ce082.js"><link rel="prefetch" href="/assets/js/13.f2032214.js"><link rel="prefetch" href="/assets/js/14.0a8927b2.js"><link rel="prefetch" href="/assets/js/15.9ab1d206.js"><link rel="prefetch" href="/assets/js/16.f03f2e40.js"><link rel="prefetch" href="/assets/js/17.c6bbe2be.js"><link rel="prefetch" href="/assets/js/18.e08bb862.js"><link rel="prefetch" href="/assets/js/19.c00af7cb.js"><link rel="prefetch" href="/assets/js/20.35396483.js"><link rel="prefetch" href="/assets/js/21.fe05d239.js"><link rel="prefetch" href="/assets/js/22.80eaa289.js"><link rel="prefetch" href="/assets/js/23.bce5e854.js"><link rel="prefetch" href="/assets/js/24.fa104861.js"><link rel="prefetch" href="/assets/js/25.2c725be9.js"><link rel="prefetch" href="/assets/js/26.fc7addb7.js"><link rel="prefetch" href="/assets/js/27.fc831a66.js"><link rel="prefetch" href="/assets/js/28.3784f580.js"><link rel="prefetch" href="/assets/js/29.7e78aa5c.js"><link rel="prefetch" href="/assets/js/30.b074fddd.js"><link rel="prefetch" href="/assets/js/31.059ebf27.js"><link rel="prefetch" href="/assets/js/32.12570018.js"><link rel="prefetch" href="/assets/js/33.d0dc971f.js"><link rel="prefetch" href="/assets/js/34.c9b46696.js"><link rel="prefetch" href="/assets/js/35.77a81c6a.js"><link rel="prefetch" href="/assets/js/36.6048e328.js"><link rel="prefetch" href="/assets/js/37.b9f285de.js"><link rel="prefetch" href="/assets/js/38.ac5a2abf.js"><link rel="prefetch" href="/assets/js/39.97ca52cb.js"><link rel="prefetch" href="/assets/js/40.1689d33f.js"><link rel="prefetch" href="/assets/js/41.4d2d8182.js"><link rel="prefetch" href="/assets/js/42.8647a8ff.js"><link rel="prefetch" href="/assets/js/44.a51272ee.js"><link rel="prefetch" href="/assets/js/45.c31e6474.js"><link rel="prefetch" href="/assets/js/46.fe85ae54.js"><link rel="prefetch" href="/assets/js/47.dc8a97d4.js"><link rel="prefetch" href="/assets/js/48.c97f7726.js"><link rel="prefetch" href="/assets/js/49.ac219d14.js"><link rel="prefetch" href="/assets/js/5.963fada3.js"><link rel="prefetch" href="/assets/js/50.926ecfa5.js"><link rel="prefetch" href="/assets/js/51.e776b5b1.js"><link rel="prefetch" href="/assets/js/52.4938314c.js"><link rel="prefetch" href="/assets/js/53.6b4d7266.js"><link rel="prefetch" href="/assets/js/54.bfaf622b.js"><link rel="prefetch" href="/assets/js/55.c6d160b9.js"><link rel="prefetch" href="/assets/js/56.31f6843c.js"><link rel="prefetch" href="/assets/js/57.55cbf7b8.js"><link rel="prefetch" href="/assets/js/58.8174871d.js"><link rel="prefetch" href="/assets/js/59.3eee2bde.js"><link rel="prefetch" href="/assets/js/6.b2e36a75.js"><link rel="prefetch" href="/assets/js/60.233a32ed.js"><link rel="prefetch" href="/assets/js/61.defb83ac.js"><link rel="prefetch" href="/assets/js/62.442070cd.js"><link rel="prefetch" href="/assets/js/63.cc121456.js"><link rel="prefetch" href="/assets/js/64.c8f83f5d.js"><link rel="prefetch" href="/assets/js/65.b9bc8c1c.js"><link rel="prefetch" href="/assets/js/7.fb6689bf.js"><link rel="prefetch" href="/assets/js/8.e390cc6b.js"><link rel="prefetch" href="/assets/js/9.c03c9dfe.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.db8a86c9.js">
    <link rel="stylesheet" href="/assets/css/0.styles.42b858ce.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Keep Running</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/kr/java/jvm/自动内存管理.html" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/kr/database/database.html" class="nav-link">
  数据库
</a></div><div class="nav-item"><a href="/kr/spring/MVC-IOC-AOP.html" class="nav-link">
  Spring
</a></div><div class="nav-item"><a href="/kr/middleware/redis/redis-base.html" class="nav-link">
  Redis/Zookeeper/Kafka
</a></div><div class="nav-item"><a href="/kr/bigdata/hadoop/Hadoop-分布式集群容器部署.html" class="nav-link">
  大数据
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/kr/java/jvm/自动内存管理.html" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/kr/database/database.html" class="nav-link">
  数据库
</a></div><div class="nav-item"><a href="/kr/spring/MVC-IOC-AOP.html" class="nav-link">
  Spring
</a></div><div class="nav-item"><a href="/kr/middleware/redis/redis-base.html" class="nav-link">
  Redis/Zookeeper/Kafka
</a></div><div class="nav-item"><a href="/kr/bigdata/hadoop/Hadoop-分布式集群容器部署.html" class="nav-link">
  大数据
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JVM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/kr/java/jvm/自动内存管理.html" class="sidebar-link">自动内存管理</a></li><li><a href="/kr/java/jvm/类加载机制.html" class="sidebar-link">类加载机制</a></li><li><a href="/kr/java/jvm/JVM-工具应用.html" class="sidebar-link">JVM 工具应用</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JUC</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/kr/java/juc/juc.html" aria-current="page" class="active sidebar-link">JUC</a></li><li><a href="/kr/java/juc/互斥同步-解决方案.html" class="sidebar-link">互斥同步-解决方案</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>集合</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/kr/java/collection/Java-集合.html" class="sidebar-link">Java 集合</a></li><li><a href="/kr/java/collection/常见容错机制.html" class="sidebar-link">常见容错机制</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Other</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/kr/java/other/docker-use.html" class="sidebar-link">Docker 使用问题记录</a></li><li><a href="/kr/java/other/Pro-Git-学习总结.html" class="sidebar-link">分布式版本控制系统 Git 学习总结</a></li><li><a href="/kr/java/other/Linux.html" class="sidebar-link">Linux</a></li></ul></section></li></ul> </aside> <div><main class="page"> <div class="theme-default-content content__default"><h1 id="juc"><a href="#juc" class="header-anchor">#</a> JUC</h1> <blockquote><p>并发编程的三个问题：</p> <ul><li>分工：如何高效地拆解任务并分配给线程</li> <li>同步：线程之间如何协作</li> <li>互斥：保证同一时刻只允许一个线程访问共享资源</li></ul> <p>并发编程中，JMM 如何处理可见性、原子性和有序性？</p></blockquote> <h2 id="硬件效率与缓存一致性"><a href="#硬件效率与缓存一致性" class="header-anchor">#</a> 硬件效率与缓存一致性</h2> <p><img src="/images/kr/java/juc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84.jpg" alt="计算机硬件结构"></p> <blockquote><p>为了合理利用 CPU 高性能，平衡 CPU 、内存、I/O 设备之间的速度差异：</p> <ul><li>CPU 增加了高速缓存，以均衡与主内存的速度差异</li> <li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异</li> <li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用</li></ul></blockquote> <p><img src="/images/kr/java/juc/%E7%A1%AC%E4%BB%B6%E6%95%88%E7%8E%87%E4%B8%8E%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7.png" alt="硬件效率与缓存一致性"></p> <blockquote><p>缓存一致性解决方案：</p> <ul><li>总线锁机制：使用 CPU 提供的一个 LOCK# 信号，当一个处理器在总线上输出此信号，其他处理器的请求将被阻塞，那么该处理器就可以独占共享锁</li> <li>缓存锁机制：总线锁开销太大，缓存锁的核心就是“缓存一致性协议”，不同的 CPU 硬件厂商实现方式稍有不同，有 MSI、MESI、MOSI 等</li></ul></blockquote> <blockquote><p><code>乱序执行优化</code>：处理器可能会对输入的代码进行<code>乱序执行</code>，处理器会在计算后重组乱序执行的结果，乱序优化可以保证在单线程下该执行结果与顺序执行的结果是一致的，但不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致</p></blockquote> <blockquote><p>乱序执行技术是处理器为提高运算速度而做出违背代码原有顺序的优化。在单核时代，处理器保证做出的优化不会导致执行结果远离预期目标，但在多核环境下却并非如此</p> <p>禁止乱序执行优化：一种 CPU 指令（<code>内存屏障</code>/<code>内存栅栏</code>），消除乱序执行在多核环境下的坏影响</p></blockquote> <h2 id="java-内存模型"><a href="#java-内存模型" class="header-anchor">#</a> Java 内存模型</h2> <blockquote><p>Java 内存模型规范了 JVM 如何提供<code>按需禁用缓存</code>（解决<code>可见性</code>问题）和<code>编译优化</code>（解决<code>有序性</code>问题）的方法，具体包括 <code>volatile</code>、<code>synchronized</code> 和 <code>final</code> 三个关键字，以及六项 <code>Happens-Before</code> 规则</p></blockquote> <p><img src="/images/kr/java/juc/%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.jpg" alt="主内存和工作内存"> <img src="/images/kr/java/juc/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="Java 内存模型"></p> <h2 id="内存屏障"><a href="#内存屏障" class="header-anchor">#</a> 内存屏障</h2> <p><code>i++</code> 对应 4 条字节码指令：（i++ 不具备原子性）</p> <ul><li>getfield：获取原始值</li> <li>iconst_1：将值入栈</li> <li>iadd：进行加 1 操作</li> <li>putfield：把 iadd 后的值写回主内存</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 双重检查创建单例对象</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>
  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
          instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>new 一个对象分三步：（不具备原子性）</p> <ul><li>给 instance 分配内存</li> <li>调用 instance 的构造函数来初始化对象</li> <li>将 instance 对象指向分配的内存空间</li></ul> <p>以上操作通过指令重排后，第二步和第三步调换了，当在 new 该对象时，还没有来得及初始化，此时访问 instance 的成员变量就可能触发空指针异常</p> <blockquote><p>Java 通过<code>内存屏障</code>保证底层操作的有序性和可见性：</p> <ul><li>内存屏障是被插入两个 CPU 指令之间的一种指令，用来禁止处理器指令发生重排序，保障有序性</li> <li>内存屏障也会使处理器写入、读取值前，将主内存的值写入高速缓存，清空无效队列，保障可见性</li></ul></blockquote> <p>常见四种屏障：</p> <ul><li>LoadLoad 屏障：在该屏障后的读取操作执行前，保证屏障前的读取操作读取的数据被读取完毕</li> <li>StoreStore 屏障：在屏障后的写入操作执行前，保证屏障前的写入操作对其它处理器可见</li> <li>LoadStore 屏障：在屏障后的写入操作执行前，保证屏障前的读取操作读取的数据被读取完毕</li> <li>StoreLoad 屏障：在屏障后的所有读取操作执行前，保证屏障后的写入对所有处理器可见，这个屏障也被称为全能屏障，兼具其它三种内存屏障的功能</li></ul> <h2 id="轻量级同步机制-volatile"><a href="#轻量级同步机制-volatile" class="header-anchor">#</a> 轻量级同步机制 Volatile</h2> <p><img src="/images/kr/java/juc/volatile.png" alt="volatile"></p> <h2 id="锁"><a href="#锁" class="header-anchor">#</a> 锁</h2> <h3 id="锁原理"><a href="#锁原理" class="header-anchor">#</a> 锁原理</h3> <p><img src="/images/kr/java/juc/%E9%94%81%E5%8E%9F%E7%90%86.png" alt="锁原理"></p> <h3 id="synchronized"><a href="#synchronized" class="header-anchor">#</a> Synchronized</h3> <blockquote><p>Synchronized 是一种独占锁，是一种悲观锁， 会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁，效率不是很高。</p></blockquote> <p><img src="/images/kr/java/juc/synchronized.png" alt="synchronized"></p> <h3 id="锁优化"><a href="#锁优化" class="header-anchor">#</a> 锁优化</h3> <blockquote><p>锁主要存在四种状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。</p></blockquote> <blockquote><p>每种锁是只能升级，不能降级，即由偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁，而这个过程就是性能开销逐渐加大的过程。</p> <ul><li>如果是单线程使用，那偏向锁毫无疑问代价最小，并且它就能解决问题，连 CAS 都不用做，仅仅在内存中比较下对象头就可以了</li> <li>如果出现了其他线程竞争，则偏向锁就会升级为轻量级锁</li> <li>如果其他线程通过一定次数的 CAS 尝试没有成功，则进入重量级锁</li></ul></blockquote> <table><thead><tr><th style="text-align:center;">锁</th> <th style="text-align:center;">优点</th> <th style="text-align:center;">缺点</th> <th style="text-align:center;">应用场景</th></tr></thead> <tbody><tr><td style="text-align:center;">偏向锁</td> <td style="text-align:center;">加锁与解锁基本不消耗资源</td> <td style="text-align:center;">如果存在线程竞争则撤销锁需要额外的消耗</td> <td style="text-align:center;">只有一个线程访问同步块的情景</td></tr> <tr><td style="text-align:center;">轻量级锁</td> <td style="text-align:center;">竞争锁不需要线程切换，提供了执行效率</td> <td style="text-align:center;">如果存在大量线程竞争锁，自旋会消耗CPU资源</td> <td style="text-align:center;">追求响应时间。适用于少量线程访问同步块，追求访问同步块的速度</td></tr> <tr><td style="text-align:center;">重量级锁</td> <td style="text-align:center;">线程不需要自旋，不会消耗过多cpu资源</td> <td style="text-align:center;">线程切换需要消耗大量资源，线程阻塞，执行缓慢</td> <td style="text-align:center;">追求吞吐量。同步块执行时间较长的情况</td></tr></tbody></table> <p><img src="/images/kr/java/juc/%E9%94%81%E4%BC%98%E5%8C%96.png" alt="锁优化"></p> <p>常见锁优化方案：</p> <ul><li>减少锁持有时间：尽可能减少同步代码块，加快同步代码块执行速度。</li> <li>减少锁的粒度：分段锁概念</li> <li>锁粗化</li> <li>锁分离（读写锁）</li> <li>使用CAS + 自旋的形式</li> <li>消除缓存行的伪共享</li></ul> <h3 id="lock"><a href="#lock" class="header-anchor">#</a> Lock</h3> <p><img src="/images/kr/java/juc/Lock.png" alt="Lock"></p> <blockquote><p>LockSupport：定义了一组的公共静态方法，提供了最基本的线程阻塞和唤醒功能</p></blockquote> <h3 id=""><a href="#" class="header-anchor">#</a></h3> <h2 id="atomic-原子类"><a href="#atomic-原子类" class="header-anchor">#</a> Atomic 原子类</h2> <p>Atomic 原子类可以保证多线程环境下，当某个线程在执行 Atomic 的方法时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，再由 JVM 从等待队列中选择一个线程执行。</p> <blockquote><p>Atomic 类在软件层面上是非阻塞的，它的原子性其实是在硬件层面上借助相关的指令来保证的。</p></blockquote> <p><code>java.util.concurrent.atomic</code>：</p> <ul><li>基本类型：AtomicBoolean，AtomicInteger，AtomicLong</li> <li>数组类型：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</li> <li>引用类型：AtomicReference，AtomicMarkableReference，AtomicStampedReference</li> <li>对象的属性修改类型（原子化对象属性更新器）：AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater</li> <li>JDK1.8 新增（原子化的累加器）：DoubleAccumulator、LongAccumulator、DoubleAdder、LongAdder、Striped64</li></ul> <blockquote><p>Atomic 中方法 compareAndSet 采用了 CAS 确保原子性</p></blockquote> <h2 id="cas"><a href="#cas" class="header-anchor">#</a> CAS</h2> <blockquote><p><a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html" target="_blank" rel="noopener noreferrer">Java魔法类：Unsafe应用解析<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p><img src="/images/kr/java/juc/CAS.png" alt="CAS"></p> <h2 id="wait-notify-等待通知机制"><a href="#wait-notify-等待通知机制" class="header-anchor">#</a> wait/notify 等待通知机制</h2> <p><img src="/images/kr/java/juc/wait-notify.png" alt="wait-notify"></p> <h2 id="condition-条件机制"><a href="#condition-条件机制" class="header-anchor">#</a> Condition 条件机制</h2> <p><img src="/images/kr/java/juc/Condition-%E6%9D%A1%E4%BB%B6%E6%9C%BA%E5%88%B6.png" alt="Condition-条件机制"></p> <h2 id="抽象队列同步器-aqs"><a href="#抽象队列同步器-aqs" class="header-anchor">#</a> 抽象队列同步器 - AQS</h2> <p>AQS：AbstractQueuedSynchronizer，抽象队列同步器，用来构建锁和同步器的框架</p> <ul><li>Abstract：AQS 是一个抽象类，只实现一些主要的逻辑，有些方法推迟到子类实现</li> <li>Queued：AQS 是用先进先出队列来存储数据的</li> <li>Synchronizer：即 AQS是 实现同步功能的</li></ul> <p><img src="/images/kr/java/juc/AQS.png" alt="AQS"> <img src="/images/kr/java/juc/CLH.png" alt="CLH"></p> <h2 id="同步容器"><a href="#同步容器" class="header-anchor">#</a> 同步容器</h2> <p>同步容器：理解为通过 Synchronized 来实现同步的容器：</p> <ul><li>Vector：Vector 与 ArrayList 基本一致，只是 Vertor 采用 Synchronized 实现方法同步</li> <li>Stack：Stack 是 Vertor 的子类，在出栈入栈等操作都进行了 Synchronized 同步</li> <li>HashTable：HashTable 与 HashMap 基本一致，HashTable 采用 Synchronized 实现方法同步</li> <li>Collections.synchronizedXXX</li></ul> <blockquote><p>同步容器通过 Synchroized 实现；削弱了并发性，竞争容器级别的锁时，降低吞吐量。</p></blockquote> <h2 id="并发容器"><a href="#并发容器" class="header-anchor">#</a> 并发容器</h2> <h3 id="concurrenthashmap"><a href="#concurrenthashmap" class="header-anchor">#</a> ConcurrentHashMap</h3> <p><img src="/images/kr/java/juc/ConcurrentHashMap.png" alt="ConcurrentHashMap"></p> <h3 id="copyonwritearraylist-copyonwritearrayset"><a href="#copyonwritearraylist-copyonwritearrayset" class="header-anchor">#</a> CopyOnWriteArrayList/CopyOnWriteArraySet</h3> <blockquote><p>Copy-On-Write 机制：对一块内存进行修改时，不在原有内存中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完后，再将指向原来内存指针指向新的内存，原来的内存就可以被回收掉</p></blockquote> <p>CopyOnWriteArrayList：底层是动态数组、通过 <code>ReentrantLock</code> 保证同步，实现机制是在对容器写操作时，copy 出一份副本数组，完成操作后将副本数组引用赋值给容器，适用场景：</p> <ul><li>集合中数据不是特别多，因为涉及到写时复制</li> <li>读多写少的场景，因为读操作不加锁，写（增、删、改）操作加锁</li></ul> <blockquote><p>局限性：通过牺牲容器的一致性（在 copy 期间读到的是旧数据）来换取容器的高并发效率，所以不适合强一致性的场景</p></blockquote> <p>CopyOnWriteArraySet：基于 CopyOnWriteArrayList 实现的，适合场景：</p> <ul><li>Set 大小通常保持很小</li> <li>只读操作远多于可变操作（可变操作（add()、set()和 remove()等等的开销很大）</li></ul> <h3 id="concurrentskiplistmap-concurrentskiplistset"><a href="#concurrentskiplistmap-concurrentskiplistset" class="header-anchor">#</a> ConcurrentSkipListMap/ConcurrentSkipListSet</h3> <blockquote><p>SkipList：跳表，跳表是一种空间换时间的数据结构，通过冗余数据，将链表一层一层索引，达到类似二分查找的效果，其数据元素默认按照 key 值升序，天然有序，运用的场景特别多，Redis 中的 Zset 就是跳表实现的</p></blockquote> <ul><li>ConcurrentSkipListMap：基于 skip list 实现有序存储的 Map，比加锁的 TreeMap 效率高</li> <li>ConcurrentSkipListSet：基于 ConcurrentNavigableMap 实现的，并发版的 TreeSet，只是有序且线程安全的</li></ul> <h3 id="非阻塞队列"><a href="#非阻塞队列" class="header-anchor">#</a> 非阻塞队列</h3> <blockquote><p>非阻塞队列可以用循环 CAS 的方式来保证数据的一致性，来达到线程安全的目的</p></blockquote> <ul><li>ConcurrentLinkedQueue：基于链表实现的无界线程安全队列，遵循队列的 FIFO 原则，队尾入队，队首出队，使用乐观锁（CAS）保证线程安全</li> <li>ConcurrentLinkedDeque：基于双向链表实现的双端并发队列，可以分别对头尾进行操作，因此除了先进先出（FIFO），也可以先进后出（FILO）</li></ul> <blockquote><p>ConcurrentLinkedQueue、ConcurrentLinkedDeque 均采用了无锁算法，底层基于 <strong>自旋 + CAS</strong> 的方式实现线程安全</p></blockquote> <h3 id="阻塞队列-blockingqueue"><a href="#阻塞队列-blockingqueue" class="header-anchor">#</a> 阻塞队列 - BlockingQueue</h3> <ul><li>DelayQueue：延时队列，无界阻塞队列
<ul><li>用于放置实现了 Delayed 接口的对象，其中对象只能在其到期时从队列中取走</li> <li>这种队列是有序的，即队头对象的延迟到期时间最长</li></ul></li> <li>ArrayBlockingQueue：基于数组实现的有界阻塞队列，有界且固定，其大小由构造函数决定，确认后就不再改变</li> <li>LinkedBlockingQueue：基于单向链表实现的无界阻塞队列</li> <li>LinkedBlockingDeque：基于双向链表实现的无界阻塞队列</li> <li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列
<ul><li>元素默认采用自然顺序升序排列，但无法保证同优先级元素的顺序</li> <li>自定义类实现 compareTo() 方法来指定元素排序规则，或初始化时，指定构造参数 Comparator 来对元素进行排序</li> <li>基于最小二叉堆实现，使用基于 CAS 实现的自旋锁来控制队列的动态扩容，保证了扩容操作不会阻塞 take 操作的执行</li></ul></li> <li>SynchronousQueue：不存储元素的阻塞队列，即是单个元素的队列
<ul><li>每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素</li> <li>SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue</li></ul></li> <li>LinkedTransferQueue：基于链表实现的无界阻塞队列
<ul><li>采用一种预占模式，就是消费者线程取元素时，如果队列不为空，则直接取走数据</li> <li>若队列为空，那就生成一个节点（节点元素为 NULL）入队，然后消费者线程被等待在这个节点上</li> <li>生产者线程入队时发现有一个元素为 NULL 的节点，生产者线程就不入队，直接就将元素填充到该节点，并唤醒该节点等待的线程</li> <li>被唤醒的消费者线程取走元素，从调用的方法返回</li></ul></li></ul> <h2 id="threadlocal"><a href="#threadlocal" class="header-anchor">#</a> ThreadLocal</h2> <blockquote><p>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景</p></blockquote> <p><img src="/images/kr/java/juc/ThreadLocal.png" alt="ThreadLocal"></p> <h2 id="线程池"><a href="#线程池" class="header-anchor">#</a> 线程池</h2> <p><img src="/images/kr/java/juc/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0.png" alt="线程池概述"> <img src="/images/kr/java/juc/Executor.png" alt="Executor"></p> <blockquote><p>Executor 接口思想：将任务提交和任务执行进行解耦，用户无需关注线程创建与调度，只需提供 Runnable 对象，将任务的运行逻辑提交到执行器(Executor)中，由 Executor 完成线程的调度和任务的执行。</p></blockquote> <h3 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h3> <p>线程池将线程和任务解耦，缓冲任务，复用线程；主要分成两部分：任务管理、线程管理</p> <ol><li>任务管理：当任务提交后，线程池会判断该任务后续的流转：</li></ol> <ul><li>直接申请线程执行该任务</li> <li>缓冲到队列中等待线程执行</li> <li>拒绝该任务</li></ul> <ol start="2"><li>线程管理：根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新任务执行，当没有任务时，非核心空闲线程在存活时间结束后被回收</li></ol> <blockquote><p>线程池生命周期：</p> <p>线程池内部使用一个变量维护两个值：运行状态（runState）和线程数量 (workerCount)，如：<code>ThreadPoolExecutor</code></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高 3 位保存 runState，低 29 位保存 workerCount</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>线程池运行状态：</p> <ul><li>RUNNING：接受新任务并处理排队任务</li> <li>STOP：不接受新任务，不处理排队任务，并中断正在运行的任务</li> <li>SHUTDOWN：不接受新任务，但处理排队任务</li> <li>TIDYING：所有任务已经终止，有效线程为零</li> <li>TERMINATED：terminate() 方法运行完成</li></ul></blockquote> <blockquote><p>任务调度：所有任务的调度都是由 execute 方法完成，工作：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务</p> <ul><li>首先检测线程池运行状态，如果不是 RUNNING，则直接拒绝，线程池要保证在 RUNNING 的状态下执行任务</li> <li>如果 workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务</li> <li>如果 workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中</li> <li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务</li> <li>如果 workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满， 则根据拒绝策略来处理该任务，默认的处理方式是直接抛异常</li></ul></blockquote> <blockquote><p>任务缓冲：阻塞队列缓存任务，工作线程从阻塞队列中获取任务，阻塞队列（BlockingQueue）是一个支持两个附加操作的队列:</p> <ul><li>在队列空时，获取元素的线程会等待队列变为非空</li> <li>当队列满时，存储元素的线程会等待队列可用</li></ul> <p><img src="/images/kr/java/juc/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt="线程池-阻塞队列"></p></blockquote> <blockquote><p>任务拒绝：当线程池的任务缓存队列已满，并且线程池中的线程数目达到 maximumPoolSize 时，采取任务拒绝策略拒绝任务，保护线程池</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
	<span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> executor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>AbortPolicy：拒绝任务，直接抛出 <code>RegectedExcutionException</code> 异常，默认策略</li> <li>DiscardPolicy:直接丢弃任务，不处理也不抛出异常</li> <li>DiscardOldestPolicy：抛弃队列中等待最久的任务</li> <li>CallerRunsPolicy：交给线程池调用者所在的线程进行处理，不抛弃任务，也不抛出异常，而是将某些任务回退到调用者</li></ul> <p><img src="/images/kr/java/juc/%E4%BB%BB%E5%8A%A1%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.png" alt="任务拒绝策略"></p></blockquote> <h3 id="threadpoolexecutor"><a href="#threadpoolexecutor" class="header-anchor">#</a> ThreadPoolExecutor</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
			<span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
			<span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
			<span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
			<span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
			<span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
			<span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span> keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> threadFactory <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
		<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>acc <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token class-name">AccessController</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p><img src="/images/kr/java/juc/ThreadPoolExecutor.png" alt="ThreadPoolExecutor"></p> <h3 id="常见线程池"><a href="#常见线程池" class="header-anchor">#</a> 常见线程池</h3> <p><img src="/images/kr/java/juc/%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="常见线程池"></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2022/6/8</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/kr/java/jvm/JVM-工具应用.html" class="prev">
          JVM 工具应用
        </a></span> <span class="next"><a href="/kr/java/juc/互斥同步-解决方案.html">
          互斥同步-解决方案
        </a>
        →
      </span></p></div> </main></div> <aside class="page-sidebar"> <div class="page-side-toolbar"><div class="option-box-toc-fixed"><div class="toc-container-sidebar"><div class="pos-box"><div class="icon-arrow"></div> <div class="scroll-box" style="max-height:650px"><div style="font-weight:bold;text-align:center;">JUC</div> <hr> <div class="toc-box"><ul class="toc-sidebar-links"><li><a href="/kr/java/juc/juc.html#硬件效率与缓存一致性" class="toc-sidebar-link">硬件效率与缓存一致性</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#java-内存模型" class="toc-sidebar-link">Java 内存模型</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#内存屏障" class="toc-sidebar-link">内存屏障</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#轻量级同步机制-volatile" class="toc-sidebar-link">轻量级同步机制 Volatile</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#锁" class="toc-sidebar-link">锁</a><ul class="toc-sidebar-sub-headers"><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#锁原理" class="toc-sidebar-link">锁原理</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#synchronized" class="toc-sidebar-link">Synchronized</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#锁优化" class="toc-sidebar-link">锁优化</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#lock" class="toc-sidebar-link">Lock</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#" class="toc-sidebar-link"></a></li></ul></li><li><a href="/kr/java/juc/juc.html#atomic-原子类" class="toc-sidebar-link">Atomic 原子类</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#cas" class="toc-sidebar-link">CAS</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#wait-notify-等待通知机制" class="toc-sidebar-link">wait/notify 等待通知机制</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#condition-条件机制" class="toc-sidebar-link">Condition 条件机制</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#抽象队列同步器-aqs" class="toc-sidebar-link">抽象队列同步器 - AQS</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#同步容器" class="toc-sidebar-link">同步容器</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#并发容器" class="toc-sidebar-link">并发容器</a><ul class="toc-sidebar-sub-headers"><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#concurrenthashmap" class="toc-sidebar-link">ConcurrentHashMap</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#copyonwritearraylist-copyonwritearrayset" class="toc-sidebar-link">CopyOnWriteArrayList/CopyOnWriteArraySet</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#concurrentskiplistmap-concurrentskiplistset" class="toc-sidebar-link">ConcurrentSkipListMap/ConcurrentSkipListSet</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#非阻塞队列" class="toc-sidebar-link">非阻塞队列</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#阻塞队列-blockingqueue" class="toc-sidebar-link">阻塞队列 - BlockingQueue</a></li></ul></li><li><a href="/kr/java/juc/juc.html#threadlocal" class="toc-sidebar-link">ThreadLocal</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#线程池" class="toc-sidebar-link">线程池</a><ul class="toc-sidebar-sub-headers"><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#原理" class="toc-sidebar-link">原理</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#threadpoolexecutor" class="toc-sidebar-link">ThreadPoolExecutor</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#常见线程池" class="toc-sidebar-link">常见线程池</a></li></ul></li></ul></div></div></div></div></div> <div class="option-box-toc-over"><img src="/images/system/toc.png" class="nozoom"> <span class="show-txt">目录</span> <div class="toc-container"><div class="pos-box"><div class="icon-arrow"></div> <div class="scroll-box" style="max-height:550px"><div style="font-weight:bold;text-align:center;">JUC</div> <hr> <div class="toc-box"><ul class="toc-sidebar-links"><li><a href="/kr/java/juc/juc.html#硬件效率与缓存一致性" class="toc-sidebar-link">硬件效率与缓存一致性</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#java-内存模型" class="toc-sidebar-link">Java 内存模型</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#内存屏障" class="toc-sidebar-link">内存屏障</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#轻量级同步机制-volatile" class="toc-sidebar-link">轻量级同步机制 Volatile</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#锁" class="toc-sidebar-link">锁</a><ul class="toc-sidebar-sub-headers"><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#锁原理" class="toc-sidebar-link">锁原理</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#synchronized" class="toc-sidebar-link">Synchronized</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#锁优化" class="toc-sidebar-link">锁优化</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#lock" class="toc-sidebar-link">Lock</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#" class="toc-sidebar-link"></a></li></ul></li><li><a href="/kr/java/juc/juc.html#atomic-原子类" class="toc-sidebar-link">Atomic 原子类</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#cas" class="toc-sidebar-link">CAS</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#wait-notify-等待通知机制" class="toc-sidebar-link">wait/notify 等待通知机制</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#condition-条件机制" class="toc-sidebar-link">Condition 条件机制</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#抽象队列同步器-aqs" class="toc-sidebar-link">抽象队列同步器 - AQS</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#同步容器" class="toc-sidebar-link">同步容器</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#并发容器" class="toc-sidebar-link">并发容器</a><ul class="toc-sidebar-sub-headers"><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#concurrenthashmap" class="toc-sidebar-link">ConcurrentHashMap</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#copyonwritearraylist-copyonwritearrayset" class="toc-sidebar-link">CopyOnWriteArrayList/CopyOnWriteArraySet</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#concurrentskiplistmap-concurrentskiplistset" class="toc-sidebar-link">ConcurrentSkipListMap/ConcurrentSkipListSet</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#非阻塞队列" class="toc-sidebar-link">非阻塞队列</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#阻塞队列-blockingqueue" class="toc-sidebar-link">阻塞队列 - BlockingQueue</a></li></ul></li><li><a href="/kr/java/juc/juc.html#threadlocal" class="toc-sidebar-link">ThreadLocal</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/kr/java/juc/juc.html#线程池" class="toc-sidebar-link">线程池</a><ul class="toc-sidebar-sub-headers"><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#原理" class="toc-sidebar-link">原理</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#threadpoolexecutor" class="toc-sidebar-link">ThreadPoolExecutor</a></li><li class="toc-sidebar-sub-header"><a href="/kr/java/juc/juc.html#常见线程池" class="toc-sidebar-link">常见线程池</a></li></ul></li></ul></div></div></div></div></div></div>  </aside></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.cfd60917.js" defer></script><script src="/assets/js/4.8234885e.js" defer></script><script src="/assets/js/3.1429892b.js" defer></script><script src="/assets/js/43.f867a280.js" defer></script>
  </body>
</html>
