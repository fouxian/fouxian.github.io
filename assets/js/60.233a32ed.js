(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{516:function(e,r,v){"use strict";v.r(r);var _=v(34),a=Object(_.a)({},(function(){var e=this,r=e.$createElement,v=e._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"zab-数据一致性及选举机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#zab-数据一致性及选举机制"}},[e._v("#")]),e._v(" Zab 数据一致性及选举机制")]),e._v(" "),v("blockquote",[v("p",[e._v("Zab：Zookeeper Atomic Broadcast，支持崩溃恢复的原子消息广播协议，通过该协议，Zookeepe 基于主从模式的系统架构来保持集群中各个副本之间数据的一致性和集群的高可用")])]),e._v(" "),v("h2",{attrs:{id:"简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[e._v("#")]),e._v(" 简介")]),e._v(" "),v("blockquote",[v("p",[e._v("注：高可用特性指的是支持通过副本机制实现崩溃恢复，ZK 集群符合 CAP 理论的 CP 架构，保证一致性，不能保证对外服务的可用性")])]),e._v(" "),v("p",[v("img",{attrs:{src:"/images/kr/zookeeper/Zookeeper-%E7%AE%80%E4%BB%8B.png",alt:"Zookeeper-简介"}})]),e._v(" "),v("h2",{attrs:{id:"集群"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#集群"}},[e._v("#")]),e._v(" 集群")]),e._v(" "),v("p",[v("img",{attrs:{src:"/images/kr/zookeeper/Zookeeper-%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2.png",alt:"Zookeeper-集群角色"}})]),e._v(" "),v("h2",{attrs:{id:"zab-消息广播"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#zab-消息广播"}},[e._v("#")]),e._v(" "),v("em",[v("strong",[e._v("Zab：消息广播")])])]),e._v(" "),v("p",[v("img",{attrs:{src:"/images/kr/zookeeper/%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD.png",alt:"消息广播"}})]),e._v(" "),v("h3",{attrs:{id:"读流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#读流程"}},[e._v("#")]),e._v(" 读流程")]),e._v(" "),v("p",[v("img",{attrs:{src:"/images/kr/zookeeper/%E8%AF%BB%E6%B5%81%E7%A8%8B.png",alt:"读流程"}}),e._v("\nLeader/Follower/Observer 都可直接处理读请求，从本地内存中读取数据并返回给客户端即可；")]),e._v(" "),v("p",[e._v("由于处理读请求不需要服务器间的交互，Follower/Observer 越多，整体系统的读请求吞吐量越大。")]),e._v(" "),v("h3",{attrs:{id:"写流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#写流程"}},[e._v("#")]),e._v(" 写流程")]),e._v(" "),v("p",[v("img",{attrs:{src:"/images/kr/zookeeper/%E5%86%99-Leader.png",alt:"消息广播：写 Leader"}}),e._v(" "),v("img",{attrs:{src:"/images/kr/zookeeper/%E5%86%99-Follower-Observer.png",alt:"消息广播：写 Follower/Observer"}}),e._v("\n::: note")]),e._v(" "),v("ul",[v("li",[e._v("Leader 不需要得到 Observer 的 ACK，即 Observer 无投票权")]),e._v(" "),v("li",[e._v("Leader 不需要得到所有 Follower 的 ACK，只要收到过半的 ACK 即可，同时 Leader 本身对自己有一个 ACK")]),e._v(" "),v("li",[e._v("Observer 虽然无投票权，但仍须同步 Leader 的数据从而在处理读请求时可以返回尽可能新的数据")]),e._v(" "),v("li",[e._v("Follower/Observer 均可接受写请求，但不能直接处理，而需要将写请求转发给 Leader 处理\n:::")])]),e._v(" "),v("h3",{attrs:{id:"问题-分布式事务两阶段提交"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题-分布式事务两阶段提交"}},[e._v("#")]),e._v(" 问题：分布式事务两阶段提交")]),e._v(" "),v("p",[e._v("ZAB 协议针对事务请求的处理过程(消息广播)类似于一个两阶段提交（2PC）过程：广播事务阶段，广播提交阶段；这两阶段提交模型有可能因为 Leader 宕机带来数据不一致，比如：")]),e._v(" "),v("ul",[v("li",[e._v("Leader 提出事务 Proposal 后就宕机（丢弃）")]),e._v(" "),v("li",[e._v("Leader 收到半数 ACK 且完成了事务提交后宕机，没来得及向 Follower/Observer 发送 Commit（保留）")])]),e._v(" "),v("p",[e._v("怎么解决呢？ZAB 引入了崩溃恢复模式")]),e._v(" "),v("h2",{attrs:{id:"zab-崩溃恢复"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#zab-崩溃恢复"}},[e._v("#")]),e._v(" "),v("em",[v("strong",[e._v("Zab：崩溃恢复")])])]),e._v(" "),v("h3",{attrs:{id:"数据同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据同步"}},[e._v("#")]),e._v(" 数据同步")]),e._v(" "),v("p",[v("img",{attrs:{src:"/images/kr/zookeeper/%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D.png",alt:"崩溃恢复"}})]),e._v(" "),v("blockquote",[v("p",[e._v("myid：每个 Zookeeper 服务器，在整个 Zookeeper 集群都有一个唯一的 ID")]),e._v(" "),v("p",[e._v("zxid：用于标识一次更新操作的事务 ID，为了保证顺序性，该 zkid 必须单调递增")])]),e._v(" "),v("h3",{attrs:{id:"过半选举"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#过半选举"}},[e._v("#")]),e._v(" 过半选举")]),e._v(" "),v("p",[e._v("选举过程中四种状态：LOOKING(选举状态)、FOLLOWING(跟随者)、LEADING(领导者)、OBSERVING(观察者)")]),e._v(" "),v("p",[v("img",{attrs:{src:"/images/kr/zookeeper/Zookeeper-%E8%BF%87%E5%8D%8A%E9%80%89%E4%B8%BE.png",alt:"Zookeeper-过半选举"}}),e._v("\n每个服务器在进行选举时，会发送如下选票数据结构：")]),e._v(" "),v("ul",[v("li",[e._v("logicClock - 每个服务器会维护一个自增的整数，名为 logicClock，它表示这是该服务器发起的第多少轮投票")]),e._v(" "),v("li",[e._v("state - 当前服务器的状态")]),e._v(" "),v("li",[e._v("self_id - 当前服务器的 myid")]),e._v(" "),v("li",[e._v("self_zxid - 当前服务器上所保存的数据的最大 zxid")]),e._v(" "),v("li",[e._v("vote_id - 被推举的服务器的 myid")]),e._v(" "),v("li",[e._v("vote_zxid - 被推举的服务器上所保存的数据的最大 zxid")])]),e._v(" "),v("p",[e._v("投票流程（先选 zxid 最大者再选 myid 最大者）")]),e._v(" "),v("ol",[v("li",[e._v("自增选举轮次：每个服务器在开始新一轮投票时，会先对自己维护的 logicClock 进行自增操作")]),e._v(" "),v("li",[e._v("初始化选票：先清空自己的投票箱，该投票箱记录了所收到的选票，每个服务器最开始都是通过广播把票投给自己")]),e._v(" "),v("li",[e._v("接收外部投票：服务器会尝试从其它服务器获取投票，并记入自己的投票箱内")]),e._v(" "),v("li",[e._v("判断选举轮次：收到外部投票后，首先会根据投票信息中所包含的 logicClock 来进行不同处理\n"),v("ul",[v("li",[e._v("外部投票的 logicClock 大于自己的 logicClock：立即清空自己的投票箱并将更新 logicClock，再对比之前的投票与收到的投票以确定是否需要变更自己的投票，最终再次将自己的投票广播出去")]),e._v(" "),v("li",[e._v("外部投票的 logicClock 小于自己的 logicClock：当前服务器直接忽略该投票，继续处理下一个投票")]),e._v(" "),v("li",[e._v("外部投票的 logickClock 与自己的相等：进行选票 PK")])])]),e._v(" "),v("li",[e._v("选票 PK：选票 PK 是基于 (self_id, self_zxid) 与 (vote_id, vote_zxid) 的对比\n"),v("ul",[v("li",[e._v("外部投票的 logicClock 大于自己的 logicClock：则将自己的 logicClock 及自己的选票的 logicClock 变更为收到的 logicClock")]),e._v(" "),v("li",[e._v("若 logicClock 一致，则对比二者的 vote_zxid，若外部投票的 vote_zxid 比较大，则将自己的票中的 vote_zxid 与 vote_myid 更新为收到的票中的 vote_zxid 与 vote_myid 并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。如果票箱内已存在(self_myid, self_zxid)相同的选票，则直接覆盖")]),e._v(" "),v("li",[e._v("若二者 vote_zxid 一致，则比较二者的 vote_myid，若外部投票的 vote_myid 比较大，则将自己的票中的 vote_myid 更新为收到的票中的 vote_myid 并广播出去，另外将收到的票及自己更新后的票放入自己的票箱")])])]),e._v(" "),v("li",[e._v("统计选票：如果已经确定有过半服务器认可了自己的投票（可能是更新后的投票），则终止投票，否则继续接收其它服务器的投票")]),e._v(" "),v("li",[e._v("更新服务器状态：投票终止后，服务器开始更新自身状态；若过半的票投给了自己，则将自己的服务器状态更新为 LEADING，否则将自己的状态更新为 FOLLOWING")])]),e._v(" "),v("p",[e._v("以上流程分析：要使 Leader 获得多数 Server 支持，则集群节点数必须是奇数，且存活节点数不得少于 N + 1\n每个 Server 启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的 server 还会从磁盘快照中恢复数据和会话信息，zk 会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。")]),e._v(" "),v("p",[e._v("参考文章：http://www.jasongj.com/zookeeper/fastleaderelection/")]),e._v(" "),v("h3",{attrs:{id:"集群脑裂"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#集群脑裂"}},[e._v("#")]),e._v(" 集群脑裂")]),e._v(" "),v("h2",{attrs:{id:"事务-zxid"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务-zxid"}},[e._v("#")]),e._v(" "),v("em",[v("strong",[e._v("事务 ZXID")])])]),e._v(" "),v("p",[e._v("对于来自客户端的每个更新请求，ZooKeeper 具备严格的顺序访问控制能力；为了保证事务的顺序一致性，ZooKeeper 采用了递增的事务 ID 号(ZXID)来标识事务，ZXID 是一个全局有序的 64 位的数字：")]),e._v(" "),v("ul",[v("li",[e._v("高 32 位是：代表着周期纪元(epoch)，每当选举产生一个新 Leader 时就会取出其本地日志中最大事务 ZXID，解析出 epoch 值并加 1作为新的 epoch ，并将低 32 位置零")]),e._v(" "),v("li",[e._v("低 32 位是： 一个简单的单调递增计数器(counter)，针对客户端的每个事务请求都会进行加 1 操作")])]),e._v(" "),v("h2",{attrs:{id:"数据一致性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据一致性"}},[e._v("#")]),e._v(" "),v("em",[v("strong",[e._v("数据一致性")])])]),e._v(" "),v("p",[e._v("ZooKeeper 在数据一致性上实现了如下几个方面：")]),e._v(" "),v("ul",[v("li",[e._v("顺序一致性：从客户端提交的更新操作是按照先后顺序排序的")]),e._v(" "),v("li",[e._v("原子性：更新操作的结果不是失败就是成功")]),e._v(" "),v("li",[e._v("系统视图唯一性：无论客户端连接到哪个服务器，都将看见唯一的系统视图。当集群一个服务器宕机，客户端去尝试连接另外一台服务器时，如果这台服务器的状态旧于之前宕机的服务器，那么服务器将不会接受客户端的连接请求，直到服务器的状态赶上之前宕机的服务器为止")]),e._v(" "),v("li",[e._v("持久性：一旦更新操作成功，数据将被持久化到服务器上，并且不能撤销，所以服务器宕机重启，也不会影响数据")]),e._v(" "),v("li",[e._v("时效性：系统视图的状态更新的延迟时间是有一个上限的，最多不过几十秒，如果服务器的状态落后于其他服务器太多，ZooKeeper会宁可关闭这个服务器上的服务，强制客户端去连接一个状态更新的服务器")])]),e._v(" "),v("p",[e._v("从执行效率上考虑，读操作的目标是内存中的缓存数据，并且读操作不会参与到写操作的全局排序中。这就会引起客户端在读取ZooKeeper的状态时产生不一致。例如，A客户端将znode z的值由a改变成a1，然后通知客户端B去读取z的值，但是B读取到的值是a，而不是修改后的a1，为了阻止这种情况出现，B在读取z的值之前，需要调用sync方法。sync方法会强制B连接的服务器状态与leader的状态同步，这样B在读取z的值就是A重新更改过的值了")])])}),[],!1,null,null,null);r.default=a.exports}}]);