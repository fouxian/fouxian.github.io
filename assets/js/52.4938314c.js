(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{508:function(a,e,r){"use strict";r.r(e);var l=r(34),_=Object(l.a)({},(function(){var a=this,e=a.$createElement,r=a._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"kafka-分区多副本可靠性剖析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kafka-分区多副本可靠性剖析"}},[a._v("#")]),a._v(" Kafka 分区多副本可靠性剖析")]),a._v(" "),r("p",[a._v("从分区多副本机制剖析 Kafka 中的数据一致性、数据可靠性等问题，参考《深入理解Kafka:核心设计与实践原理》")]),a._v(" "),r("blockquote",[r("ul",[r("li",[a._v("Kafka 分区多副本机制，可实现水平扩展、提供容灾能力、提升数据可用性和可靠性及自动故障转移等")]),a._v(" "),r("li",[a._v("Kafka 分区多副本之间如何进行数据同步？在分区副本发生异常时又如何处理？")]),a._v(" "),r("li",[a._v("分区多副本间的数据一致性如何解决？又是采用什么样的一致性协议？")]),a._v(" "),r("li",[a._v("如何确保 Kafka 的可靠性？Kafka 中的可靠性和可用性之间的关系又如何？")])])]),a._v(" "),r("h2",{attrs:{id:"分布式系统副本概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分布式系统副本概念"}},[a._v("#")]),a._v(" "),r("em",[r("strong",[a._v("分布式系统副本概念")])])]),a._v(" "),r("p",[a._v("副本（Replica）指的是分布式系统对数据和服务提供的一种冗余方式，以提升数据和服务的容灾能力，实现数据和服务的高可用。在常见的分布式系统中，为了对外提供可用的服务，往往会对数据和服务进行副本处理：")]),a._v(" "),r("ul",[r("li",[a._v("数据副本是指在不同的节点上持久化同一份数据，当某一个节点上存储的数据丢失时，可以从副本上读取该数据")]),a._v(" "),r("li",[a._v("服务副本是指多个节点提供对外同样的服务，每个节点都有能力接收来自外部的请求并进行相应的处理")])]),a._v(" "),r("h2",{attrs:{id:"kafka-分区多副本机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kafka-分区多副本机制"}},[a._v("#")]),a._v(" "),r("em",[r("strong",[a._v("Kafka 分区多副本机制")])])]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/kafka/%E5%88%86%E5%8C%BA%E5%A4%9A%E5%89%AF%E6%9C%AC%E6%9E%B6%E6%9E%84.jpg",alt:"分区多副本架构"}})]),a._v(" "),r("blockquote",[r("ul",[r("li",[a._v("副本类型：leader 副本对外提供读写服务，follower 副本负责内部消息同步，各个副本位于不同 broker 节点")]),a._v(" "),r("li",[a._v("AR(Assigned Replicas)：分区中所有副本集合，其中第一副本称为优先副本(理想情况下，为该分区 leader 副本)")]),a._v(" "),r("li",[a._v("ISR(In-Sync Replicas)：与 leader 副本保持一定程度同步状态（滞后）的副本集合(包括 leader 副本)，同步副本列表")]),a._v(" "),r("li",[a._v("OSR(Out-of-Sync Replicas)：与 leader 副本同步状态滞后过多的副本集合(不包括 leader 副本)")]),a._v(" "),r("li",[a._v("AR = ISR + OSR；在正常情况下，所有 follower 副本都应该与 leader 副本保持一定程度同步，即 AR=ISR，OSR=null")])])]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/kafka/%E5%88%86%E5%8C%BA%E5%89%AF%E6%9C%AC(%E4%B8%80%E4%B8%AA%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6)%E4%B8%AD%E5%90%84%E4%B8%AA%E5%81%8F%E7%A7%BB%E9%87%8F.jpg",alt:"分区副本(一个日志文件)中各个偏移量"}})]),a._v(" "),r("blockquote",[r("ul",[r("li",[a._v("LEO(Log End Offset)：标识每个分区副本中下一条待写入消息的偏移量，分区的每个副本都有自己的 LEO")]),a._v(" "),r("li",[a._v("HW(High Watermark) 标识了特定消息偏移量，ISR 中最小 LEO 即为 HW(高水位)，消费者只能拉取到 HW 前的消息")]),a._v(" "),r("li",[a._v("新消息消费时点：从生产者发出的一条消息首先会被写入分区的 leader 副本，不过还需要等待 ISR 中的所有 follower 副本都同步完之后才会更新分区的 HW，进而消费者可以消费到这条消息")])])]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/kafka/%E5%89%AF%E6%9C%AC%E9%97%B4%E6%B6%88%E6%81%AF%E5%90%8C%E6%AD%A5%E4%B8%8ELEO-HW%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg",alt:"副本间消息同步与LEO-HW示意图"}})]),a._v(" "),r("ul",[r("li",[a._v("同步复制：所有能工作的 follower 副本都同步复制完，这条消息才会被确认为已成功提交，但极大地影响了性能")]),a._v(" "),r("li",[a._v("异步复制：follower 副本异步地从 leader 副本中复制数据，数据只要被 leader 副本写入就被认为已经成功提交")]),a._v(" "),r("li",[a._v("同步复制和异步复制是针对生成者生成消息时，等待 ACK 应答响应的情况：同步(ACK=-1)，异步(ACK=1)")]),a._v(" "),r("li",[a._v("在同步复制下，leader 和 follower 副本全部完成消息的落地，影响性能")]),a._v(" "),r("li",[a._v("在异步复制下，follower 副本复制数据存在一定程度的滞后性，若 leader 副本宕机，则会造成数据丢失，不可靠")]),a._v(" "),r("li",[a._v("Kafka 使用的 ISR/LEO/HW 的方式则有效地权衡了数据可靠性和性能之间的关系")])]),a._v(" "),r("h2",{attrs:{id:"失效副本-同步失效分区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#失效副本-同步失效分区"}},[a._v("#")]),a._v(" "),r("em",[r("strong",[a._v("失效副本/同步失效分区")])])]),a._v(" "),r("blockquote",[r("p",[a._v("失效副本：OSR 中的副本处于功能失效或同步失效，称为失效副本，对应的分区称为同步失效分区(under-replicated)\n判定一个分区是否有副本处于同步失效的状态：")]),a._v(" "),r("p",[a._v("当 ISR 中一个 follower 副本滞后 leader 副本的时间超过指定的值(replica.lag.time.max.ms)时则判定为同步失效，将此 follower 副本从 ISR 移至 OSR")]),a._v(" "),r("p",[a._v("注意：副本 lastCaughtUpTimeMs 更新时点，是同步 leader 副本 LEO 前的所有日志才更新，不是有同步数据就更新")])]),a._v(" "),r("p",[a._v("当 follower 副本将 leader 副本 LEO 之前的日志全部同步时，则认为该 follower 副本已经追赶上 leader 副本，此时更新该副本的 lastCaughtUpTimeMs 标识并加入 ISR；")]),a._v(" "),r("p",[a._v("Kafka 的副本管理器会启动一个副本过期检测的定时任务，而这个定时任务会定时检查当前时间与副本的 lastCaughtUpTimeMs 差值是否大于参数 replica.lag.time.max.ms 指定的值。")]),a._v(" "),r("p",[a._v("导致副本失效的两种情况：")]),a._v(" "),r("ul",[r("li",[a._v("follower 副本进程卡住，在一段时间内根本没有向 leader 副本发起同步请求，比如频繁的 Full GC")]),a._v(" "),r("li",[a._v("follower 副本进程同步过慢，在一段时间内都无法追赶上 leader 副本，比如 IO 开销过大")])]),a._v(" "),r("h2",{attrs:{id:"kafka-不支持读写分离-负载均衡-优先副本选举-分区副本分配-分区副本重分配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kafka-不支持读写分离-负载均衡-优先副本选举-分区副本分配-分区副本重分配"}},[a._v("#")]),a._v(" "),r("em",[r("strong",[a._v("Kafka 不支持读写分离？/负载均衡/优先副本选举/分区副本分配/分区副本重分配")])])]),a._v(" "),r("p",[a._v("主写从读有两个明显的缺点：数据不一致和延时问题；主写从读可以均摊一定的负载却不能做到完全的负载均衡，比如对于数据写压力很大而读压力很小的情况，从节点只能分摊很少的读压力，而绝大多数写压力还是在主节点上。")]),a._v(" "),r("blockquote",[r("p",[a._v("理想部署情况下，Kafak 的分区 leader 副本均衡分布在各个 broker 节点上，在 leader 提供读写服务的主写主读模式下实现了 broker 的负载均衡（关键点：broker 节点中 leader 副本个数决定了该节点负载高低，如何分区均衡分布？）")]),a._v(" "),r("p",[a._v("在一定程度上造成 broker 负载失衡的因素：\nbroker 的分区副本分配不均、主从副本的切换(分区副本重分配)不均、生产者写入消息不均、消费者消费消息不均")])]),a._v(" "),r("ul",[r("li",[a._v("分区副本故障自动转移：当 leader 副本宕机/崩溃时，需从 ISR 中选举一个 leader 副本，提升高可用性")]),a._v(" "),r("li",[a._v("分区副本故障自动转移会造成一定程度上的分区分配不均，导致集群负载失衡，从而影响整体的健壮性和稳定性")]),a._v(" "),r("li",[a._v("注意：分区副本分配均衡、leader 分配均衡只是一定程度上保持负载均衡，但每个分区 leader 副本负载可能不同")])]),a._v(" "),r("p",[a._v("解决方案：优先副本选举（分区平衡），是指通过一定的方式促使优先副本选举为 leader 副本，促进集群负载均衡")]),a._v(" "),r("p",[a._v("分区自动平衡：auto.leader.rebalance.enable=true，默认开启，通过定时任务会轮询所有的 broker 节点，计算每个 broker 节点的分区不平衡率，当分区不平衡率超过指定比值则自动执行优先副本的选举以求分区平衡")]),a._v(" "),r("blockquote",[r("p",[a._v("分区不平衡率：broker 中的不平衡率 = 非优先副本的 leader 个数/分区总数")]),a._v(" "),r("p",[a._v("不建议生产环境开启分区自动平衡，通过 kafka-perferred-replica-election.sh 脚本实现对分区 leader 副本进行重新平衡")])]),a._v(" "),r("p",[a._v("分区副本分配/分区副本重分配的目的：Kafka 要确保所有主题的优先副本在集群中均匀分布，保证集群负载均衡")]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/kafka/%E5%88%86%E5%8C%BA%E5%89%AF%E6%9C%AC%E5%88%86%E9%85%8D.png",alt:"分区副本分配"}}),a._v(" "),r("img",{attrs:{src:"/images/kr/kafka/%E5%88%86%E5%8C%BA%E5%89%AF%E6%9C%AC%E9%87%8D%E5%88%86%E9%85%8D.png",alt:"分区副本重分配"}})]),a._v(" "),r("p",[a._v("参考文章：\n"),r("a",{attrs:{href:"https://blog.csdn.net/weixin_39756235/article/details/111262728",target:"_blank",rel:"noopener noreferrer"}},[a._v("kafka原理_Kafka中副本机制的设计和原理"),r("OutboundLink")],1),a._v("、"),r("a",{attrs:{href:"https://blog.csdn.net/weixin_43230682/article/details/107317839",target:"_blank",rel:"noopener noreferrer"}},[a._v("kafka中的AR、ISR、LEO、HW分别是什么"),r("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=_.exports}}]);