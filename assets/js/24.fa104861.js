(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{480:function(a,t,r){"use strict";r.r(t);var e=r(34),n=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"集群资源管理与调度平台-yarn-概述及原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#集群资源管理与调度平台-yarn-概述及原理"}},[a._v("#")]),a._v(" 集群资源管理与调度平台 YARN 概述及原理")]),a._v(" "),r("blockquote",[r("p",[a._v("Yarn 是通用的集群资源管理与调度平台，能够管理分布式应用以及合理地调度集群资源，可以在保证应用正常运行的前提下，尽可能提高资源利用率。"),r("br"),a._v("从编程模型角度看，YARN 与传统并行编程模式非常像，但兼具了分布式和并行两个特点；"),r("br"),a._v("从资源管理系统角度看，YARN 将扮演为上层计算框架提供计算资源的角色；"),r("br"),a._v("从云计算角度看，YARN 可看做轻量级的 PAAS 层。")])]),a._v(" "),r("h2",{attrs:{id:"轻量级弹性计算平台"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#轻量级弹性计算平台"}},[a._v("#")]),a._v(" 轻量级弹性计算平台")]),a._v(" "),r("p",[a._v("相比“一个计算引擎一个集群”模式，共享集群具备：资源利用率高、运维成本低、方便数据共享等优点，以 YARN 为核心的弹性计算平台基础架构：")]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%BC%B9%E6%80%A7%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0.jpg",alt:"以 YARN 为核心的弹性计算平台基础架构"}})]),a._v(" "),r("h2",{attrs:{id:"yarn-主从体系架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#yarn-主从体系架构"}},[a._v("#")]),a._v(" YARN 主从体系架构")]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/YARN-%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.jpg",alt:"YARN 体系架构"}})]),a._v(" "),r("ul",[r("li",[a._v("ResourceManager(RM)：负责管理和调度整个集群资源，及管理分布式应用，集群总资源是各个从节点（NM）通过心跳进行汇报的\n"),r("ul",[r("li",[a._v("调度器(Scheduler)：根据容量、队列等限制及应用程序资源需求进行资源分配（资源容器）")]),a._v(" "),r("li",[a._v("应用程序管理器(Applications Manager，ASM)：管理集群中所有应用程序，包括作业提交、资源请求、启动并监控 AM、及 AM 失败重启等")])])]),a._v(" "),r("li",[a._v("NodeManager(NM)：负责单个集群节点的资源和任务管理，负责管理及监控 Container，定时向 RM 汇报本节点资源情况，执行分配的任务以及处理 RM/AM 请求")]),a._v(" "),r("li",[a._v("ApplicationMaster(AM)：每个应用程序均包含一个 AM，主要功能：\n"),r("ul",[r("li",[a._v("与 RM 调度器协商并获取资源，再分配给内部任务")]),a._v(" "),r("li",[a._v("任务的监控、及任务失败后资源申请和任务重启")])])]),a._v(" "),r("li",[a._v("Container：抽象的资源容器，封装节点的多维度资源：内存、网络、CPU、磁盘等\n"),r("ul",[r("li",[a._v("动态资源划分单位，是根据应用程序的资源需求动态生成")]),a._v(" "),r("li",[a._v("YARN 为每个任务分配一个资源容器，且该任务只能使用该资源容器")])])])]),a._v(" "),r("h2",{attrs:{id:"resourcemanager-解析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#resourcemanager-解析"}},[a._v("#")]),a._v(" ResourceManager 解析")]),a._v(" "),r("p",[a._v("ResourceManager 负责集群中所有资源的统一管理和分配，它接收各个节点（NodeManager）的资源汇报信息，并把这些信息按照一定的策略分配给各个应用程序（ApplicationMaster）。")]),a._v(" "),r("h3",{attrs:{id:"内部架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内部架构"}},[a._v("#")]),a._v(" 内部架构")]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/ResourceManager-%E6%9E%B6%E6%9E%84.jpg",alt:""}})]),a._v(" "),r("ul",[r("li",[a._v("用户交互：针对普通用户/管理员/Web 的对外服务 ClientRMService/AdminService/RMWebApp")]),a._v(" "),r("li",[a._v("NM 管理：用于管理监控 NodeManager\n"),r("ul",[r("li",[a._v("NMLivelinessMonitor：监控 NM 存活状态，若一定时间 NM 未发送心跳，则从集群中移除")]),a._v(" "),r("li",[a._v("NodesListManager：维护正常节点和异常节点的列表，在配置文件设置，可动态加载")]),a._v(" "),r("li",[a._v("ResourceTrackerService：处理 NM 注册和心跳请求")])])]),a._v(" "),r("li",[a._v("AM 管理：用于管理监控 ApplicationMaster\n"),r("ul",[r("li",[a._v("AMLivelinessMonitor：监控 AM 存活状态，若一定时间 AM 未发送心跳，则重新分配节点")]),a._v(" "),r("li",[a._v("ApplicationMasterLauncher：与 NM 通信，请求为某个应用程序启动 ApplicationMaster")]),a._v(" "),r("li",[a._v("ApplicationMasterService(AMS)：处理 AM 注册和心跳请求")])])]),a._v(" "),r("li",[a._v("应用管理：\n"),r("ul",[r("li",[a._v("ApplicationACLsManage：管理应用程序访问（查询和修改）权限")]),a._v(" "),r("li",[a._v("RMAppManager：管理应用程序的启动和关闭")]),a._v(" "),r("li",[a._v("ContainerAllocationExpirer：决定和执行一个已分配的 Container 是否该被回收")])])]),a._v(" "),r("li",[a._v("状态机管理：ResourceManager 使用有限状态机维护有状态对象的生命周期，共 4 类状态机\n"),r("ul",[r("li",[a._v("RMApp：维护一个应用程序所有运行实例的整个运行周期，包括从启动到运行结束整个过程")]),a._v(" "),r("li",[a._v("RMAppAttempt：维护一次运行尝试（一个应用程序每次启动运行实例）的整个生命周期")]),a._v(" "),r("li",[a._v("RMContainer：维护一个 Container 的运行周期，包括从创建到运行结束整个过程")]),a._v(" "),r("li",[a._v("RMNode：维护一个 NodeManager 的生命周期，包括启动到运行结束整个过程")])])]),a._v(" "),r("li",[a._v("安全管理：RM 自带了非常全面的权限管理机制")]),a._v(" "),r("li",[a._v("资源分配：ResourceScheduler 是一个可插拔的资源调度器，按一定约束条件将集群资源分配给应用程序，主要有批处理资源调度器(FIFO)、多用户调度器(FairScheduler、CapacityScheduler)")])]),a._v(" "),r("h3",{attrs:{id:"基本功能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本功能"}},[a._v("#")]),a._v(" 基本功能")]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/ResourceManager-RPC%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD.jpg",alt:""}})]),a._v(" "),r("ul",[r("li",[a._v("与客户端交互，处理客户端提交应用程序、查询应用程序状态和控制应用程序等请求")]),a._v(" "),r("li",[a._v("启动和管理 ApplicationMaster，资源管理与调度")]),a._v(" "),r("li",[a._v("管理 NodeManager，接收 NodeManager 的资源汇报信息")])]),a._v(" "),r("h3",{attrs:{id:"事件与事件处理器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事件与事件处理器"}},[a._v("#")]),a._v(" 事件与事件处理器")]),a._v(" "),r("p",[a._v("YARN 采用了事件驱动机制，而 ResourceManager 的实现则是一个最好的例证。所有服务和组件均是通过中央异步调度器组织在一起的，不同组件之间通过事件交互，从而实现了一个异步并行的高效系统。")]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/ResourceManager-%E4%BA%8B%E4%BB%B6%E5%8F%8A%E5%A4%84%E7%90%86%E5%99%A8.jpg",alt:""}})]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/ResourceManager-%E4%BA%8B%E4%BB%B6%E5%8F%8A%E5%A4%84%E7%90%86%E5%99%A8%E4%BA%A4%E4%BA%92%E5%9B%BE.jpg",alt:""}})]),a._v(" "),r("h3",{attrs:{id:"资源调度器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#资源调度器"}},[a._v("#")]),a._v(" 资源调度器")]),a._v(" "),r("p",[a._v("资源调度器是 ResourceManager 中的一个插拔式服务组件，也是一个事件处理器，负责整个集群资源的管理和分配，它定义了一整套接口规范以便用户自定义实现调度器。YARN 支持三种调度器：FIFO Scheduler、Capacity Scheduler、Fair Scheduler。在 YARN 中，资源调度器是以层级队列方式组织资源的，有利于资源在不同用户间分配和共享，进而提高集群资源利用率。\nHadoop3 默认资源调度器为 Capacity Scheduler；而 CDH 默认资源调度器为 Fair Scheduler")]),a._v(" "),r("h4",{attrs:{id:"调度器基本架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#调度器基本架构"}},[a._v("#")]),a._v(" 调度器基本架构")]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84.jpg",alt:""}})]),a._v(" "),r("ul",[r("li",[a._v("NODE_REMOVED：表示集群中移除了计算节点，调度器需要从可分配资源总量中移除相应资源量")]),a._v(" "),r("li",[a._v("NODE_ADDED：表示集群中增加了计算节点，调度器需要将新增资源量添加到可分配资源总量中")]),a._v(" "),r("li",[a._v("APPLICATION_ADDED：表示 RM 收到新的应用，调度器需将该应用添加到相应的数据结构中")]),a._v(" "),r("li",[a._v("APPLICATION_REMOVED：表示应用程序运行结束，调度器需将该应用从相应数据结构中清除")]),a._v(" "),r("li",[a._v("CONTAINER_EXPIRED：当调度器将 Container 分配给 AM，若 AM 一定时间内没有使用，则回收再分配 Container")]),a._v(" "),r("li",[a._v("NODE_UPDATE：RM 收到 NM 心跳机制汇报信息后，会触发调度器最核心的资源分配机制")])]),a._v(" "),r("h4",{attrs:{id:"双层资源调度模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#双层资源调度模型"}},[a._v("#")]),a._v(" 双层资源调度模型")]),a._v(" "),r("ul",[r("li",[a._v("RM 中资源调度器将资源分配给各个 AM（分配空闲资源给应用程序的调度策略由调度器实现）")]),a._v(" "),r("li",[a._v("AM 再将资源分配给内部各个任务（AM 的调度策略由应用程序实现）")])]),a._v(" "),r("p",[a._v("YARN 资源分配过程是异步的，资源调度器将资源暂放到一个缓冲区中，由 AM 周期性心跳拉取资源\n"),r("img",{attrs:{src:"/images/kr/bigdata/hadoop/%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%99%A8%E5%88%86%E9%85%8D%E8%B5%84%E6%BA%90.jpg",alt:""}})]),a._v(" "),r("ol",[r("li",[a._v("NM 周期性心跳汇报节点信息")]),a._v(" "),r("li",[a._v("RM 向 NM 返回心跳应答，包含需释放的 Container 列表等信息")]),a._v(" "),r("li",[a._v("RM 收到 NM 信息后，会触发一个 NODE_UPDATE 事件")]),a._v(" "),r("li",[a._v("调度器收到 NODE_UPDATE 事件后，按照策略将该节点上的资源分配各应用程序，并将分配结果放到一个内存数据结构中")]),a._v(" "),r("li",[a._v("应用程序的 AM 向 RM 发送周期性心跳，领取最新分配的 Container")]),a._v(" "),r("li",[a._v("RM 收到 AM 心跳信息后，为它分配的 Container 将以心跳应答形式返回给 AM")]),a._v(" "),r("li",[a._v("AM 收到新分配 Container 列表后，会将这些 Container 进一步分配给内部各个任务")])]),a._v(" "),r("h4",{attrs:{id:"资源保证机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#资源保证机制"}},[a._v("#")]),a._v(" 资源保证机制")]),a._v(" "),r("p",[a._v("在分布式计算中，资源调度器通过资源保证机制来保证应用程序能够获取到满足的资源以完成计算：")]),a._v(" "),r("ul",[r("li",[a._v("增量资源分配：优先为应用程序预留一个节点上的资源直到累计释放的空闲资源满足应用程序需求")]),a._v(" "),r("li",[a._v("一次性资源分配：暂时放弃当前资源直到出现一个节点剩余资源一次性满足应用程序需求")])]),a._v(" "),r("p",[a._v("对于增量资源分配，资源预留会导致资源浪费，降低集群资源利用率；而一次性资源分配会产生饥饿现象，应用程序可能永远等不到满足资源需求的节点出现。YARN 采用了增量资源分配机制。")]),a._v(" "),r("h4",{attrs:{id:"资源调度算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#资源调度算法"}},[a._v("#")]),a._v(" 资源调度算法")]),a._v(" "),r("p",[a._v("为了支持多维资源调度，YARN 资源调度器采用了主资源公平调度算法（Dominant Resource Fairness，DRF），该算法扩展了最大最小公平（max-min fairness）算法，使其能够支持多维资源的调度。\n在 DRF 算法中，将所需份额（资源比例）最大的资源称为主资源，而 DRF 的基本设计思想则是将最大最小公平算法应用于主资源上，进而将多维资源调度问题转化为单资源调度问题，即 DRF 总是最大化所有主资源中最小的，其算法伪代码如下：")]),a._v(" "),r("div",{staticClass:"language-js line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[a._v("DRFScheduler")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),r("span",{pre:!0,attrs:{class:"token constant"}},[a._v("R")]),a._v(" ← "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("r1"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("...")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" rm"),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("                      "),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// m 种资源对应的容量")]),a._v("\n    "),r("span",{pre:!0,attrs:{class:"token constant"}},[a._v("C")]),a._v(" ← "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("c1"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("...")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" cm"),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("                      "),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 已用掉资源，初始值为 0")]),a._v("\n    "),r("span",{pre:!0,attrs:{class:"token function"}},[a._v("si")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("i "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[a._v("1.")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("                          "),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 用户 i 的主资源所需份额，初始值为 0")]),a._v("\n    Ui ← "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("ui"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("...")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" ui"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" m"),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("i "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[a._v("1.")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("        "),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 分配给用户 i 的资源，初始值为 0")]),a._v("\n    "),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 挑选出主资源所需份额 si 最小的用户 i")]),a._v("\n    Di ← "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("用户 i 的下一个任务需要的资源量"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token constant"}},[a._v("C")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" Di "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<=")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token constant"}},[a._v("R")]),a._v(" then\n        "),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 将资源分配给用户 i")]),a._v("\n        "),r("span",{pre:!0,attrs:{class:"token constant"}},[a._v("C")]),a._v(" ← "),r("span",{pre:!0,attrs:{class:"token constant"}},[a._v("C")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" Di"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("                         "),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 更新 C")]),a._v("\n        Ui ← Ui "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" Di"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("                       "),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 更新 U")]),a._v("\n        si "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" maxmj"),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),r("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("ui"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" j"),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("rj"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("else")]),a._v("\n        "),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("                            "),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 资源全部用完")]),a._v("\n    end "),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v("\nend "),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v("\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br"),r("span",{staticClass:"line-number"},[a._v("3")]),r("br"),r("span",{staticClass:"line-number"},[a._v("4")]),r("br"),r("span",{staticClass:"line-number"},[a._v("5")]),r("br"),r("span",{staticClass:"line-number"},[a._v("6")]),r("br"),r("span",{staticClass:"line-number"},[a._v("7")]),r("br"),r("span",{staticClass:"line-number"},[a._v("8")]),r("br"),r("span",{staticClass:"line-number"},[a._v("9")]),r("br"),r("span",{staticClass:"line-number"},[a._v("10")]),r("br"),r("span",{staticClass:"line-number"},[a._v("11")]),r("br"),r("span",{staticClass:"line-number"},[a._v("12")]),r("br"),r("span",{staticClass:"line-number"},[a._v("13")]),r("br"),r("span",{staticClass:"line-number"},[a._v("14")]),r("br"),r("span",{staticClass:"line-number"},[a._v("15")]),r("br"),r("span",{staticClass:"line-number"},[a._v("16")]),r("br")])]),r("h3",{attrs:{id:"capacity-scheduler"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#capacity-scheduler"}},[a._v("#")]),a._v(" Capacity Scheduler")]),a._v(" "),r("p",[a._v("多用户调度器 Capacity Scheduler 以队列为单位划分资源，设计了多层级别的资源限制条件以更好地让多用户共享一个集群。每个队列可设定一定比例的资源最低保证和使用上限，同时，每个用户也可设定一定的资源使用上限以防止资源滥用，而当一个队列的资源有剩余时，可暂时将剩余资源共享给其他队列，特点：")]),a._v(" "),r("ul",[r("li",[a._v("容量保证：管理员可为每个队列设置资源最低保证和资源使用上限，而所有提交到该队列的应用程序共享这些资源")]),a._v(" "),r("li",[a._v("资源灵活：若一个队列中资源有剩余，可暂时共享给其它队列，当该队列有新的应用程序提交，则其它队列释放的资源会归还给该队列")]),a._v(" "),r("li",[a._v("多重租赁：支持多用户共享集群和多应用程序同时运行，为防止单个应用程序、用户或者队列独占集群中的资源，管理员可为之增加多重约束")]),a._v(" "),r("li",[a._v("安全保证：每个队列有严格的 ACL 列表规定访问用户，每个用户可指定哪些用户允许查看自己应用程序的运行状态或者控制应用程序")]),a._v(" "),r("li",[a._v("动态更新配置文件：管理员可根据需要动态修改各种配置参数，以实现在线集群管理")])]),a._v(" "),r("p",[a._v("Capacity Scheduler 将整个系统资源分成若干个队列，且每个队列有较为严格的资源使用限制，包括每个队列的资源容量限制、每个用户的资源量限制等。通过这些限制，Capacity Scheduler 将整个 Hadoop 集群逻辑上划分成若干个拥有相对独立资源的子集群，而由于这些子集群实际上是公用大集群中的资源，因此可以共享资源，提高了资源利用率且降低了运维成本。\nYARN 采用了三级资源分配策略，当一个节点上有空闲资源时，依次选择队列、应用程序和 container 使用该资源：\n"),r("img",{attrs:{src:"/images/kr/bigdata/hadoop/%E4%B8%89%E7%BA%A7%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D.jpg",alt:""}})]),a._v(" "),r("ul",[r("li",[a._v("选择队列：\n"),r("ul",[r("li",[a._v("YARN 采用了层次结构组织队列，但实际存放应用程序的只有叶子队列，其它队列只是一个逻辑概念，用以辅助计算叶子队列的资源量")]),a._v(" "),r("li",[a._v("选择队列实际上就是根据当前所有队列的资源使用情况查找一个最合适的叶子队列（）")]),a._v(" "),r("li",[a._v("Fair Scheduler 也采用了深度优先遍历算法选择队列（基于优先级的多叉树遍历的过程）\n"),r("ul",[r("li",[a._v("从根队列开始，使用 FIFO/Fair/DRF 策略对其所有子队列进行排序，再依次处理子队列")]),a._v(" "),r("li",[a._v("对于某个子队列，若是叶子队列则直接返回，否则以该队列为根队列，继续按策略查找")])])])])]),a._v(" "),r("li",[a._v("选择应用程序：按照提交时间对叶子队列内部应用程序进行排序，并依次遍历排序后的应用程序")]),a._v(" "),r("li",[a._v("选择 Container：尝试优先满足优先级高的 Container，其次，优先选择满足本地性的 Container")])]),a._v(" "),r("h3",{attrs:{id:"fair-scheduler"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fair-scheduler"}},[a._v("#")]),a._v(" Fair Scheduler")]),a._v(" "),r("p",[a._v("Fair Scheduler 是 Facebook 开发的多用户调度器，以队列为单位划分资源，设计了多层级别的资源限制条件以更好地让多用户共享一个集群，每个队列可设定一定比例的资源最低保证和使用上限，每个用户也可设定一定的资源使用上限以防止资源滥用，当一个队列的资源有剩余时，可暂时将剩余资源共享给其他队列，而当该队列中有新的应用程序提交时，调度器要为它回收资源。Fair Scheduler 也采用了三级资源分配策略。特点：")]),a._v(" "),r("ul",[r("li",[a._v("资源公平共享：在每个队列中，可选择按照 FIFO/Fair/DRF 策略为应用程序分配资源。其中，Fair 是一种基于最大最小公平算法实现的资源多路复用方式，默认情况下，每个队列内部采用该方式分配资源")]),a._v(" "),r("li",[a._v("支持资源抢占：调度器采用了先等待再强制回收的策略，即等待一段时间后尚有未归还的资源，则会进行资源抢占：从那些超额使用资源的队列中杀死一部分任务，进而释放资源")]),a._v(" "),r("li",[a._v("负载均衡：提供了一个基于任务数目的负载均衡机制，该机制尽可能将系统中的任务均匀分配到各个节点上")]),a._v(" "),r("li",[a._v("调度策略配置灵活：允许管理员为每个队列单独设置调度策略")]),a._v(" "),r("li",[a._v("提高小应用程序响应时间：由于采用了最大最小公平算法，小作业可以快速获取资源并运行完成")])]),a._v(" "),r("p",[a._v("Fair Scheduler 允许在队列间和队列内部单独配置调度策略：FIFO、Fair、DRF，即先来先服务、公平调度、主资源公平调度：")]),a._v(" "),r("ul",[r("li",[a._v("FIFO：按照优先级高低调度，如果优先级相同，则按照提交时间先后顺序调度，如果提交时间也相同，则按照（队列或者应用程序）名称大小（字符串比较）调度")]),a._v(" "),r("li",[a._v("Fair：按照内存资源使用量比率调度，即按照 used_memory/minShare 大小调度（核心思想是按照该调度算法决定调度顺序，但还需考虑一些边界情况）")]),a._v(" "),r("li",[a._v("DRF：按照主资源公平调度算法进行调度")])]),a._v(" "),r("h3",{attrs:{id:"两个调度器比较"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#两个调度器比较"}},[a._v("#")]),a._v(" 两个调度器比较")]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/Capacity-Fair.jpg",alt:""}})]),a._v(" "),r("h3",{attrs:{id:"资源抢占模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#资源抢占模型"}},[a._v("#")]),a._v(" 资源抢占模型")]),a._v(" "),r("p",[a._v("在资源调度器中，每个队列可设置一个最小资源量和最大资源量：")]),a._v(" "),r("ul",[r("li",[a._v("最小资源量是资源紧缺情况下每个队列需保证的资源量")]),a._v(" "),r("li",[a._v("最大资源量则是极端情况下队列也不能超过的资源使用量")])]),a._v(" "),r("p",[a._v("为了提高资源利用率，资源调度器会将负载较轻的队列的资源暂时分配给负载重的队列，仅当负载较轻队列突然收到新提交的应用程序时，调度器必须等待其他队列释放资源后，收回本属于该队列的资源并分配给新应用程序；为了防止应用程序等待时间过长，调度器等待一段时间后若发现资源并未得到释放，则进行资源抢占：")]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/%E8%B5%84%E6%BA%90%E6%8A%A2%E5%8D%A0%E6%B5%81%E7%A8%8B.jpg",alt:""}})]),a._v(" "),r("p",[a._v("关于资源抢占的实现，通常涉及以下几个需认真考虑的问题：")]),a._v(" "),r("ul",[r("li",[a._v("如何决定是否抢占某个队列的资源？")]),a._v(" "),r("li",[a._v("如何使资源抢占代价最小？")])]),a._v(" "),r("h2",{attrs:{id:"yarn-层级队列管理机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#yarn-层级队列管理机制"}},[a._v("#")]),a._v(" YARN 层级队列管理机制")]),a._v(" "),r("p",[a._v("层级队列组织方式：")]),a._v(" "),r("ul",[r("li",[a._v("子队列\n"),r("ul",[r("li",[a._v("队列可以嵌套，每个队列均可以包含子队列")]),a._v(" "),r("li",[a._v("用户只能将应用程序提交到最底层的队列，即叶子队列")])])]),a._v(" "),r("li",[a._v("最少容量\n"),r("ul",[r("li",[a._v("每个子队列均有一个“最少容量比”属性，表示可以使用父队列容量的百分比")]),a._v(" "),r("li",[a._v("调度器总是优先选择当前资源使用率最低的队列，并为之分配资源")]),a._v(" "),r("li",[a._v("最少容量不是“总会保证的最低容量”")]),a._v(" "),r("li",[a._v("最少容量的值为不小于 0 的数，但也不能大于“最大容量”")])])]),a._v(" "),r("li",[a._v("最大容量\n"),r("ul",[r("li",[a._v("通过最大容量防止一个队列超量使用资源，任何时刻使用的资源总量都不能超过该值")]),a._v(" "),r("li",[a._v("默认情况下队列的最大容量是无限大，其他队列没有应用程序时，该队列可能其资源，当其他队列有应用程序提交时，再逐步归还")])])])]),a._v(" "),r("p",[a._v("Hadoop 队列管理机制由用户权限管理和系统资源管理两部分组成：")]),a._v(" "),r("ul",[r("li",[a._v("用户权限管理：Hadoop的用户管理模块构建在操作系统用户管理之上，增加了“队列”这一用户组织单元，并通过队列建立了操作系统用户和用户组之间的映射关系。管理员可配置每个叶子队列对应的操作系统用户和用户组（需要注意的是，Hadoop允许一个操作系统用户或者用户组可对应一个或者多个队列），也可以配置每个队列的管理员，他可以杀死该队列中任何应用程序，改变任何应用程序的优先级等（默认情况下每个用户只能管理自己的应用程序）")]),a._v(" "),r("li",[a._v("系统资源管理：YARN资源管理和调度均由调度器完成，管理员可在调度器中设置每个队列的资源容量，每个用户可用资源量等信息，而调度器则按照这些资源约束对应用程序进行调度")])]),a._v(" "),r("h2",{attrs:{id:"yarn-工作流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#yarn-工作流程"}},[a._v("#")]),a._v(" YARN 工作流程")]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/YARN-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg",alt:""}}),a._v("\nYARN 分两阶段运行应用程序：第一阶段是启动 ApplicationMaster；第二阶段是由 ApplicationMaster 创建应用程序，申请资源并监控整个运行过程，直到运行完成")]),a._v(" "),r("ol",[r("li",[a._v("提交应用程序：提交应用程序，包括 ApplicationMaster 程序、用户程序、启动命令等")]),a._v(" "),r("li",[a._v("分配资源：RM 为应用程序分配 Container，并通过 NM 在 Container 中启动应用程序的 AM")]),a._v(" "),r("li",[a._v("注册 AM：AM 向 RM 注册，并为各个任务申请资源及监控任务状态，直到任务运行结束，即4-7步")]),a._v(" "),r("li",[a._v("申请资源：AM 采用轮询方式向 RM 申请资源")]),a._v(" "),r("li",[a._v("启动任务：当 AM 申请到资源后，通过 NM 启动任务")]),a._v(" "),r("li",[a._v("配置及启动：NM 为任务配置好运行环境后，将任务启动命令写到脚本，并通过该脚本启动任务")]),a._v(" "),r("li",[a._v("任务汇报：各个任务向 AM 汇报任务状态和进度，以便 AM 在任务失败时进行重试")]),a._v(" "),r("li",[a._v("注销 AM：应用程序运行结束后，AM 向 RM 注销并关闭")])]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/%E5%88%86%E5%B8%83%E5%BC%8F%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B-YARN.jpg",alt:"从分布式并行编程理解 YARN 工作流程"}})]),a._v(" "),r("h2",{attrs:{id:"yarn-通信协议"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#yarn-通信协议"}},[a._v("#")]),a._v(" YARN 通信协议")]),a._v(" "),r("p",[a._v("在 YARN 中，任何两个需要相互通信的组件之间仅有一个 RPC 协议，而对于任何一个 RPC 协议，总是 Client 主动连接 Server。因此，YARN 实际上采用拉式（pull-based）通信模型：")]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/YARN-RPC.jpg",alt:""}})]),a._v(" "),r("ul",[r("li",[a._v("ApplicationClientProtocol：JobClient 通过该 RPC 协议提交应用程序、查询应用程序状态等")]),a._v(" "),r("li",[a._v("ResourceManagerAdministrationProtocol：Admin 通过该 RPC 协议更新系统配置文件")]),a._v(" "),r("li",[a._v("ApplicationMasterProtocol：AM 通过该 RPC 协议向 RM 注册和注销自己，并为各个任务申请资源")]),a._v(" "),r("li",[a._v("ContainerManagementProtocol：AM 通过该 RPC 协议要求 NM 启动或停止 Container，获取各个 Container 的使用状态等")]),a._v(" "),r("li",[a._v("ResourceTracker：NM 通过该 RPC 协议向 RM 注册，并定时发送心跳信息汇报当前节点资源情况和 Container 运行情况")])]),a._v(" "),r("p",[a._v("YARN 中序列化框架采用了 Google 开源的 Protocol Buffers，使得 YARN 具有协议向后兼容性。")]),a._v(" "),r("h2",{attrs:{id:"nodemanager-解析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#nodemanager-解析"}},[a._v("#")]),a._v(" NodeManager 解析")]),a._v(" "),r("p",[a._v("NodeManager（NM）是 YARN 中单个节点上的代理，管理 Hadoop 集群中单个计算节点，功能包括与 RM 保持通信、管理 Container 生命周期、监控 Container 的资源使用情况、追踪节点健康状况、管理日志和不同应用程序用到的附属服务等。")]),a._v(" "),r("h3",{attrs:{id:"内部架构-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内部架构-2"}},[a._v("#")]),a._v(" 内部架构")]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/NodeManager-%E5%86%85%E9%83%A8%E6%9E%B6%E6%9E%84.jpg",alt:""}})]),a._v(" "),r("ul",[r("li",[a._v("NodeStatusUpdater：是 NM 与 RM 通信的唯一通道，向 RM 进行资源汇报和周期性心跳")]),a._v(" "),r("li",[a._v("ContainerManager：管理本节点所有 Container\n"),r("ul",[r("li",[a._v("RPC Server：是 AM 与 NM 通信的唯一通道，ContainerManager 接收请求以执行操作 Container（Container 操作均通过 ContainerTokenSecretManager 进行合法性验证）")]),a._v(" "),r("li",[a._v("ResourceLocalizationService：负责 Container 所需资源的本地化")]),a._v(" "),r("li",[a._v("ContainersLauncher：维护了一个线程池以并行完成 Container 相关操作")]),a._v(" "),r("li",[a._v("AuxServices：NM 允许用户通过配置附属服务的方式扩展功能，由 NM 统一启动与关闭")]),a._v(" "),r("li",[a._v("ContainersMonitor：周期性监控 Container 资源使用量\n"),r("ul",[r("li",[a._v("内存资源：通过 ContainersMonitor 监控方式加以限制")]),a._v(" "),r("li",[a._v("CPU 资源：采用了轻量级资源隔离方案 Cgroups")])])]),a._v(" "),r("li",[a._v("LogHandler：一个可插拔组件，用户通过它控制 Container 日志保存方式")]),a._v(" "),r("li",[a._v("ContainerEventDispatcher：Container 事件调度器，负责将 ContainerEvent 类型事件调度给对应 Container 状态机")]),a._v(" "),r("li",[a._v("ApplicationEventDispatcher：Application 事件调度器，负责将 ApplicationEvent 类型事件调度给对应 Application 状态机")])])]),a._v(" "),r("li",[a._v("ContainerExecutor：可与底层操作系统交互，安全存放 Container 需要的文件和目录，进而以一种安全的方式启动和清除 Container 对应进程\n"),r("ul",[r("li",[a._v("DefaultContainerExecutor：默认实现，未提供任何安全措施，以 NM 启动者的身份启动和停止 Container")]),a._v(" "),r("li",[a._v("LinuxContainerExecutor：以应用程序拥有者的身份启动和停止 Container，因此更加安全，并允许用户通过 Cgroups 对 CPU 资源进行隔离")])])]),a._v(" "),r("li",[a._v("NodeHealthCheckerService：通过周期性运行一个自定义脚本（由 NodeHealthScriptRunner 完成）和向磁盘写文件（由 LocalDirsHandlerService 完成）检查节点的健康状况")]),a._v(" "),r("li",[a._v("DeletionService：文件删除服务，实现异步删除失效文件，可避免同步删除带来的性能开销")]),a._v(" "),r("li",[a._v("Security：安全模块，主要包括\n"),r("ul",[r("li",[a._v("ApplicationACLsManager：为每个应用程序维护一个 ACL，确保访问 NM 的用户是合法")]),a._v(" "),r("li",[a._v("ContainerTokenSecretManager：检查各种访问请求合法性，确保请求的资源被 RM 授权过")])])]),a._v(" "),r("li",[a._v("WebServer：展示该节点上所有应用程序运行状态、节点健康状况、Container 列表与日志等信息")])]),a._v(" "),r("h3",{attrs:{id:"节点健康状态检测"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#节点健康状态检测"}},[a._v("#")]),a._v(" 节点健康状态检测")]),a._v(" "),r("p",[a._v("节点健康状态检测是 NM 自带的健康状态诊断机制，该机制不仅可帮助及时发现存在问题的 NM，避免不必要的任务分配，也可以用于动态升级（通过脚本指示 RM 不再分配任务，等到 NM 任务运行完成后，对它进行升级）")]),a._v(" "),r("h4",{attrs:{id:"健康检测脚本"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#健康检测脚本"}},[a._v("#")]),a._v(" 健康检测脚本")]),a._v(" "),r("p",[a._v('NodeHealthScriptRunner 周期性执行节点健康状态检测脚本并检查脚本输出，该服务通过配置一个“健康检测脚本”以检查节点健康状态，且可在该脚本中添加任何检查语句作为节点是否健康运行的依据。一旦脚本输出是以"ERROR"开头的字符串，则认为检测到节点处于不健康状态，进行标记并心跳通知 RM，RM 将其加入黑名单，此后不再为它分配新任务，当节点恢复后，RM 将其从黑名单中移出，从而可以重新接收任务分配。该机制的好处：')]),a._v(" "),r("ul",[r("li",[a._v("可作为节点负载的反馈")]),a._v(" "),r("li",[a._v("人为暂时维护 NM 节点")])]),a._v(" "),r("h4",{attrs:{id:"磁盘损坏检测"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#磁盘损坏检测"}},[a._v("#")]),a._v(" 磁盘损坏检测")]),a._v(" "),r("p",[a._v("LocalDirsHandlerService 周期性检测 NM 本地磁盘好坏（目录可用性），一旦发现正常磁盘的比例低于一定的比例（默认 0.25），则认为节点处于不健康状态，便心跳通知 RM，从而不再接收新任务。\n在配置 YARN 时，会设置 NM 本地可用目录列表和日志存放目录列表，这些目录的可用性直接决定着 NM 的可用性；NM 判断一个目录（磁盘）好坏的方法是：若一个目录具有读、写和执行权限，则认为是正常的，否则将被加入坏磁盘列表，此后不再使用。")]),a._v(" "),r("h3",{attrs:{id:"分布式缓存机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分布式缓存机制"}},[a._v("#")]),a._v(" 分布式缓存机制")]),a._v(" "),r("p",[a._v("在 YARN 中，分布式缓存是一种分布式文件分发与缓存机制。其主要作用是将用户应用程序执行时所需的外部文件资源自动透明地从 HDFS 下载并缓存到各个节点上，从而省去了用户手动部署文件的麻烦。")]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/YARN-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.jpg",alt:""}})]),a._v(" "),r("ol",[r("li",[a._v("客户端将应用程序所需的文件资源（外部字典、JAR包、二进制文件等）上传至 HDFS")]),a._v(" "),r("li",[a._v("客户端将应用程序提交到 ResourceManager 上")]),a._v(" "),r("li",[a._v("RM 与某个 NM 通信，NM 收到命令后，首先从 HDFS 下载文件（缓存），然后启动 AM")]),a._v(" "),r("li",[a._v("AM 与 RM 通信，以请求和获取计算资源")]),a._v(" "),r("li",[a._v("AM 收到新分配的计算资源后，与对应的 NM 通信，以启动任务")]),a._v(" "),r("li",[a._v("如果该应用程序第一次在该节点上启动任务，则 NM 先从 HDFS 上缓存文件到本地，再启动任务")]),a._v(" "),r("li",[a._v("NM 后续收到启动任务请求后，若文件已在本地缓存，则直接运行，否则等待文件缓存完再启动")])]),a._v(" "),r("blockquote",[r("p",[a._v("在 Hadoop 中，分布式缓存并不是将文件缓存到集群中各节点内存中，而是将文件缓存到各节点本地磁盘上，以便执行任务时直接从本地磁盘上读取文件；由于分布式缓存可以对文本文件、目录、JAR 包和归档文件等进行下载与缓存。为了规范化，统一将文本文件、目录、JAR 包和归档文件等称为“资源”。")])]),a._v(" "),r("h4",{attrs:{id:"资源可见性与分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#资源可见性与分类"}},[a._v("#")]),a._v(" 资源可见性与分类")]),a._v(" "),r("p",[a._v("按照可见性（LocalResourceVisibility），NM 将资源分为三类：")]),a._v(" "),r("ul",[r("li",[a._v("PUBLIC：节点上所有用户的所有应用程序均可共享其它用户的其它应用程序缓存到本地的资源")]),a._v(" "),r("li",[a._v("PRIVATE：节点上同一用户的所有应用程序均可共享同一用户的其它应用程序缓存到本地的资源")]),a._v(" "),r("li",[a._v("APPLICATION：节点上同一程序的所有 Container 共享，其它用户/同一用户的其它程序不可使用")])]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/%E8%B5%84%E6%BA%90%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E5%88%86%E7%B1%BB.jpg",alt:""}})]),a._v(" "),r("p",[a._v("按照资源类型（LocalResourceType），NM 将资源分为三类：")]),a._v(" "),r("ul",[r("li",[a._v("ARCHIVE：归档文件，支持后缀为 jar/zip/tar.gz/tgz/tar 的归档文件，NM 能自动在工作目录中对归档文件进行解压缩（若是 jar 文件，还可自动将其加到 CLASSPATH 中）")]),a._v(" "),r("li",[a._v("FILE：普通文件，NM 只是简单地将这类文件下载到工作目录中，不做任何处理")]),a._v(" "),r("li",[a._v("PATTERN：以上两种类型的混合体，有多种类型文件存在，而用户可通过一个正则表达式指定哪些属于 ARCHIVE 文件，需要自动解压缩")])]),a._v(" "),r("h4",{attrs:{id:"分布式缓存实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分布式缓存实现"}},[a._v("#")]),a._v(" 分布式缓存实现")]),a._v(" "),r("p",[a._v("通过设置特殊的目录位置和目录权限实现不同可见性的资源开放给用户不同的权限，NM 采用轮询分配策略将三类资源存放在 ${yarn.nodemanager.local-dirs} 指定的目录列表中，在每个目录中，资源将按照以下方式存放：")]),a._v(" "),r("ul",[r("li",[a._v("PUBLIC：\n"),r("ul",[r("li",[a._v("${yarn.nodemanager.local-dirs}/filecache/")]),a._v(" "),r("li",[a._v("每个资源将单独存放在以一个随机整数命名的目录中，且目录的访问权限均为 0755")])])]),a._v(" "),r("li",[a._v("PRIVATE：\n"),r("ul",[r("li",[a._v("${yarn.nodemanager.local-dirs}/usercache/${user}/filecache/")]),a._v(" "),r("li",[a._v("每个资源将单独存放在以一个随机整数命名的目录中，且目录的访问权限均为 0710")])])]),a._v(" "),r("li",[a._v("APPLICATION：\n"),r("ul",[r("li",[a._v("${yarn.nodemanager.local-dirs}/usercache/${user}/${appcache}/${appid}/filecache/")]),a._v(" "),r("li",[a._v("每个资源将单独存放在以一个随机整数命名的目录中，且目录的访问权限均为 0710")])])])]),a._v(" "),r("blockquote",[r("p",[a._v("Container 工作目录：")]),a._v(" "),r("p",[a._v("${yarn.nodemanager.local-dirs}/usercache/${user}/${appcache}/${appid}/${containerid}")]),a._v(" "),r("p",[a._v("它运行所需外部资源，处于各个 filecache 目录中，为了避免文件复制带来性能影响，它会建立一个到这些文件的软连接。")])]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg",alt:""}})]),a._v(" "),r("ul",[r("li",[a._v("对于 PUBLIC 资源，由ResourceLocalizationService 中一个公用线程 PublicLocalizer 下载，它内部维护了一个线程池并行下载资源")]),a._v(" "),r("li",[a._v("对于 PRIVATE/APPLICATION 资源，则由 ResourceLocalizationService 中一个专门线程 LocalizerRunner下载，同一个 Container 的所有资源是串行下载")]),a._v(" "),r("li",[a._v("分布式缓存整个过程采用了异步并发模型以加快文件下载速度，同时避免同步模型带来的性能开销")]),a._v(" "),r("li",[a._v("NM 定期清理过期缓存文件：每隔一定时间启动一次清理工作，确保每个缓存目录中文件容量小于设定值，如果超过设定值，则采用 LRU 算法清除已不再使用的缓存文件，直至文件容量低于设定值")])]),a._v(" "),r("h3",{attrs:{id:"目录结构管理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#目录结构管理"}},[a._v("#")]),a._v(" 目录结构管理")]),a._v(" "),r("ul",[r("li",[a._v("数据目录：存放 Container 所需数据和产生的临时数据，由 yarn.nodemanager.local-dirs 指定")]),a._v(" "),r("li",[a._v("日志目录：存放 Container 运行时输出日志，由 yarn.nodemanager.log-dirs 指定")])]),a._v(" "),r("h4",{attrs:{id:"数据目录管理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据目录管理"}},[a._v("#")]),a._v(" 数据目录管理")]),a._v(" "),r("p",[a._v("通过参数 yarn.nodemanager.local-dirs 配置多个数据目录以分摊负载；NM 在每个磁盘上为作业创建了相同的目录结构，且采用轮询的调度方式将目录（磁盘）分配给不同的 Container 的不同模块以避免干扰。")]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg",alt:""}})]),a._v(" "),r("p",[a._v("考虑到一个应用程序的不同 Container 之间可能存在依赖，为了避免提前清除已经运行完成的 Container 输出的中间数据破坏应用程序的设计逻辑，YARN 统一规定，只有当应用程序运行结束后，才统一清除 Container 产生的中间数据。")]),a._v(" "),r("h4",{attrs:{id:"日志目录管理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#日志目录管理"}},[a._v("#")]),a._v(" 日志目录管理")]),a._v(" "),r("p",[a._v("通过参数 yarn.nodemanager.log-dirs 配置多个日志目录以分摊负载；NM 会在所有目录上为同一个应用程序建立相同的目录结构，并采用轮询的调度方式将这些目录分配给不同 Container 使用。每个 Container 将输出三类日志：")]),a._v(" "),r("ul",[r("li",[a._v("stdout：使用标准输出函数打印的日志")]),a._v(" "),r("li",[a._v("stderr：标准错误输出产生的日志信息")]),a._v(" "),r("li",[a._v("syslog：使用 log4j 打印的日志信息，默认")])]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/kr/bigdata/hadoop/%E6%97%A5%E5%BF%97%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg",alt:""}})]),a._v(" "),r("p",[a._v("NM 将定期清理日志文件，该功能由组件 LogHandler 完成，NM 提供了定期删除和日志聚集转存两种日志清理机制：")]),a._v(" "),r("ul",[r("li",[a._v("定期删除：NM 允许应用程序日志在磁盘上的保留时间为 yarn.nodemanager.log.retain-seconds（秒，默认为3小时），一旦超过，NM 会将该应用程序所有日志从磁盘上删除，默认机制，由 NonAggregatingLogHandler 实现")]),a._v(" "),r("li",[a._v("日志聚集转存：由 LogAggregationService 实现，配置参数 yarn.log-aggregation-enable = true 启用该功能；该机制将 HDFS 作为日志聚集仓库，将应用程序产生的日志上传到 HDFS 上，以便统一管理和维护。该机制由两阶段组成：文件上传和文件生命周期管理\n"),r("ul",[r("li",[a._v("文件上传：同一个节点中所有日志保存到 HDFS 指定目录中的同一个文件（以节点 ID 命名），一旦日志全部上传到 HDFS 后，本地磁盘上的日志文件将被删除")]),a._v(" "),r("li",[a._v("文件生命周期管理：转存到 HDFS 上的日志的生命周期不再由 NM 负责，而是由 JobHistory 管理")])])])]),a._v(" "),r("h3",{attrs:{id:"状态机管理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#状态机管理"}},[a._v("#")]),a._v(" 状态机管理")]),a._v(" "),r("p",[a._v("NM 维护了三类状态机：Application、Container和LocalizedResource，它们均直接或间接参与维护一个应用程序的生命周期。")]),a._v(" "),r("ul",[r("li",[a._v("Application：对一个节点上同一个 Application 的所有 Container 进行统一管理，记录了 Application 可能存在的各个状态以及导致状态间转换的事件")]),a._v(" "),r("li",[a._v("Container：维护一个 Container 生命周期的数据结构，记录了 Container 可能存在的各个状态以及导致状态间转换的事件")]),a._v(" "),r("li",[a._v("LocalizedResource：用于维护一种资源生命周期的数据结构，记录了资源可能存在的各个状态以及导致状态间转换的事件")])]),a._v(" "),r("h3",{attrs:{id:"container-生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#container-生命周期"}},[a._v("#")]),a._v(" Container 生命周期")]),a._v(" "),r("p",[a._v("Container 启动命令是由 AM 通过 RPC 协议 ContainerManagementProtocol 向 NM 发起，NM 中 ContainerManager 负责接收并处理该请求。Container 启动过程主要三个阶段：")]),a._v(" "),r("ul",[r("li",[a._v("资源本地化：完成分布式缓存机制，由 ResourceLocalizationService 完成主要工作：\n"),r("ul",[r("li",[a._v("应用程序初始化：初始化各类服务组件（日志记录组件、资源状态追踪组件等）")]),a._v(" "),r("li",[a._v("Container 本地化：创建工作目录、从 HDFS 下载运行所需的各种资源")]),a._v(" "),r("li",[a._v("总结：同一应用程序所有 Container 状态机异步并发向 ResourceLocalizationService 请求资源；ResourceLocalizationService 下载完一类资源后，将通知依赖该资源的所有 Container；一旦一个 Container 依赖的资源已经全部下载完成，则该 Container 进入运行阶段")])])]),a._v(" "),r("li",[a._v("启动运行：由 ContainersLauncher 完成 Container 启动，该服务将进一步调用插拔式组件 ContainerExecutor（实现：DefaultContainerExecutor、LinuxContainerExecutor）\n"),r("ul",[r("li",[a._v("将待运行 Container 所需的环境变量和运行命令写到 Shell 脚本 launch_container.sh 中")]),a._v(" "),r("li",[a._v("并将启动该脚本的命令写入 default_container_executor.sh 中并运行启动 Container")])])]),a._v(" "),r("li",[a._v("资源清理：资源本地化的逆过程，负责清理各种资源\n"),r("ul",[r("li",[a._v("ResourceLocalizationService：清理从 HDFS 下载并缓存的资源")]),a._v(" "),r("li",[a._v("ContainerExecutor：清理为 Container 创建的工作目录及目录下的临时文件")])])])]),a._v(" "),r("h3",{attrs:{id:"资源隔离"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#资源隔离"}},[a._v("#")]),a._v(" 资源隔离")]),a._v(" "),r("p",[a._v("资源隔离是指为不同任务提供可独立使用的计算资源以避免它们相互干扰。YARN 对内存资源和 CPU 资源采用了不同的资源隔离方案。")])])}),[],!1,null,null,null);t.default=n.exports}}]);