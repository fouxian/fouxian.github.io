(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{513:function(a,t,v){"use strict";v.r(t);var _=v(34),r=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"消息可靠性和幂等性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息可靠性和幂等性"}},[a._v("#")]),a._v(" 消息可靠性和幂等性")]),a._v(" "),v("blockquote",[v("p",[a._v("金字塔思维：从不同维度上来思考问题的一种方式")])]),a._v(" "),v("h2",{attrs:{id:"可靠性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#可靠性"}},[a._v("#")]),a._v(" 可靠性")]),a._v(" "),v("p",[a._v("消息可靠性，就是消息的丢失问题，从生产者 100% 投递、MQ 持久化与高可用、消费者 100% 消费三个角度去考虑")]),a._v(" "),v("p",[v("img",{attrs:{src:"/images/kr/kafka/MQ%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98.png",alt:"MQ消息丢失问题"}})]),a._v(" "),v("h3",{attrs:{id:"rabbitmq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq"}},[a._v("#")]),a._v(" RabbitMQ")]),a._v(" "),v("p",[a._v("RabbitMQ 采用消息确认机制"),v("code",[a._v("confirm")]),a._v("保障消息可靠性")]),a._v(" "),v("ul",[v("li",[a._v("生产者\n"),v("ul",[v("li",[a._v("生产者开启 confirm 消息确认机制后，每条消息会分配一个唯一 ID")]),a._v(" "),v("li",[a._v("Broker 收到消息后发送 ACK应答给生产者，回调 ConfirmCallback 接口")]),a._v(" "),v("li",[a._v("如果消息丢失，Broker 发送 nack 应答给生产者，回调 ReturnCallback 接口")])])])]),a._v(" "),v("blockquote",[v("p",[a._v("ACK NACK 只有一个被触发，且是异步执行的")])]),a._v(" "),v("ul",[v("li",[a._v("消费者\n"),v("ul",[v("li",[a._v("声明队列时，指定noack=false， 表示消费者不会自动提交ack，broker会等待消费者手动返回ack、才会删除消息，否则立刻删除")])])])]),a._v(" "),v("blockquote",[v("p",[a._v("除了消息确认机制，RabbitMQ 使用事务消息方式：消息生产端发送commit命令，MQ同步返回commit ok命令，这种方式由于需要同步阻塞等待MQ返回是否投递成功，才能执行别的操作，性能较差（同步方式）")])]),a._v(" "),v("ul",[v("li",[a._v("MQ：MQ 本身实现消息持久化")])]),a._v(" "),v("h3",{attrs:{id:"kafka"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#kafka"}},[a._v("#")]),a._v(" Kafka")]),a._v(" "),v("ul",[v("li",[a._v("生产者\n"),v("ul",[v("li",[a._v("ACK 机制，同步落盘")]),a._v(" "),v("li",[a._v("失败重试")])])]),a._v(" "),v("li",[a._v("消费者：手动/自动提交 Offset 偏移量，一般在完成消息消费后手动提交 offset，确认消息成功消费")]),a._v(" "),v("li",[a._v("MQ：Kafka 的持久化机制（日志存储）和分区多副本实现消息的高可靠性")])]),a._v(" "),v("h2",{attrs:{id:"幂等性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#幂等性"}},[a._v("#")]),a._v(" 幂等性")]),a._v(" "),v("h2",{attrs:{id:"消息积压"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息积压"}},[a._v("#")]),a._v(" 消息积压")]),a._v(" "),v("h3",{attrs:{id:"rabbitmq-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-2"}},[a._v("#")]),a._v(" RabbitMQ")]),a._v(" "),v("p",[a._v("MQ 出现消息积压的几种情况：")]),a._v(" "),v("ul",[v("li",[a._v("消费者消费消息的速度赶不上生产速度，这种问题主要是生产者和消费者业务逻辑没有设计好")]),a._v(" "),v("li",[a._v("消费者出现异常，导致一直无法接收新的消息，这种问题需要排查消费逻辑")]),a._v(" "),v("li",[a._v("MQ 本身故障恢复时间较长，导致消息积压")]),a._v(" "),v("li",[a._v("还有一些业务情况，在某段时间内消息的生产速度和频率大大超过正常值")])]),a._v(" "),v("p",[a._v("解决思路")]),a._v(" "),v("ul",[v("li",[a._v("拆分MQ，生产者一个MQ，消费者一个MQ，写一个程序监听生产者的MQ，然后发送到消费者MQ，如果消息积压则只需要处理生产者MQ的积压消息，不影响消费者MQ")]),a._v(" "),v("li",[a._v("使用Redis的List或ZSET做接收消息缓存，写一个程序按照消费者处理时间定时从Redis取消息发送到MQ")]),a._v(" "),v("li",[a._v("设置消息过期时间，过期后转入死信/延时队列，写一个程序处理死信消息")])]),a._v(" "),v("h3",{attrs:{id:"kafka-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#kafka-2"}},[a._v("#")]),a._v(" Kafka")]),a._v(" "),v("p",[a._v("Kafka消息积压的典型场景：")]),a._v(" "),v("ul",[v("li",[a._v("实时/消费任务挂掉，导致消费滞后，消息积压")]),a._v(" "),v("li",[a._v("Kafka 分区数设置的不合理（太少），影响消费的吞吐量")]),a._v(" "),v("li",[a._v("Kafka消息的 key 不均匀，导致分区间数据不均衡")])]),a._v(" "),v("p",[a._v("解决思路：\n*")])])}),[],!1,null,null,null);t.default=r.exports}}]);