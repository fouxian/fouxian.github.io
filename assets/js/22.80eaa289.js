(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{478:function(a,e,s){"use strict";s.r(e);var t=s(34),r=Object(t.a)({},(function(){var a=this,e=a.$createElement,s=a._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"分布式文件系统-hdfs-体系架构及原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式文件系统-hdfs-体系架构及原理"}},[a._v("#")]),a._v(" 分布式文件系统 HDFS 体系架构及原理")]),a._v(" "),s("blockquote",[s("p",[a._v("分布式文件系统 HDFS 是基于流式数据模式访问和处理超大文件的海量数据存储解决方案，具备在通用硬件集群中进行分布式文件存储的能力，具有高容错、高可靠性、高可扩展性、高吞吐量等特征。")])]),a._v(" "),s("p",[a._v("Hadoop Distributed File System，HDFS：Hadoop 分布式文件系统；\nHadoop 中有一个综合性的文件系统抽象，它提供了文件系统实现的各类接口，而 HDFS 只是这个抽象文件系统的一种具体实现。")]),a._v(" "),s("p",[a._v("特点：处理超大文件、运行于廉价的商用机器集群上、高容错性、高可靠性、流式数据访问")]),a._v(" "),s("p",[a._v("局限：不适合低延迟数据访问、无法高效存储大量小文件、不支持多用户写入和随机文件修改\n（在HDFS的一个文件中只有一个写入者，而且写操作只能在文件末尾完成，即只能执行追加操作。目前HDFS还不支持多个用户对同一文件的写操作，也不支持在文件任意位置进行修改）")]),a._v(" "),s("h2",{attrs:{id:"hdfs-主从体系架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hdfs-主从体系架构"}},[a._v("#")]),a._v(" HDFS 主从体系架构")]),a._v(" "),s("p",[s("img",{attrs:{src:"/images/kr/bigdata/hadoop/HDFS-%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.jpg",alt:""}}),a._v("\n分布式文件系统 HDFS 采用 Master-Slave 主从架构模式（一主多从）：")]),a._v(" "),s("ul",[s("li",[a._v("NameNode：负责文件系统命名空间、文件目录信息、文件数据块信息(元数据)的管理，主要功能是对内存及 IO 进行集中管理，负责接受用户操作请求")]),a._v(" "),s("li",[a._v("SecondaryNameNode：辅助监控 HDFS 状态，辅助 NameNode 管理元数据信息，定期保存 HDFS 元数据快照，用以备份和恢复数据，但不支持热备")]),a._v(" "),s("li",[a._v("DataNode：负责文件数据块（多副本机制）的存储管理，定期向 Namenode 发送文件数据块信息")])]),a._v(" "),s("h2",{attrs:{id:"namenode"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#namenode"}},[a._v("#")]),a._v(" NameNode")]),a._v(" "),s("p",[a._v("NameNode 中元数据信息存储（启动时加载到内存），主要存储文件：")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("root@xzx-hadoop namenode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# tree -C")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v(".")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# NameNode 中文件路径由 hdfs-default.xml 中 dfs.namenode.name.dir 配置")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- current\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- VERSION     "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 记录集群信息，HDFS 格式化后集群信息发生变化，故 HDFS 只格式化一次")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- edits_0000000000000000001-0000000000000000002   "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# edits：事务日志文件，记录对文件的操作")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- edits_0000000000000000003-0000000000000000003\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- edits_0000000000000000004-0000000000000000004\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- edits_0000000000000000005-0000000000000000006\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- edits_0000000000000000007-0000000000000000008\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- edits_0000000000000000009-0000000000000000010\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- edits_0000000000000000011-0000000000000000012\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- edits_0000000000000000013-0000000000000000014\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- edits_0000000000000000015-0000000000000000016\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- edits_0000000000000000017-0000000000000000018\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- edits_inprogress_0000000000000000019\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- fsimage_0000000000000000016         "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# fsimage：filesystem image，文件系统(元数据)镜像，存储某时刻 NameNode 内存中元数据信息(快照操作)")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- fsimage_0000000000000000016.md5     "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 通过 md5 加密 fsimage，通过 md5 值判断 fsimage 是否完整")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- fsimage_0000000000000000018\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("-- fsimage_0000000000000000018.md5\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token variable"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("`")]),a._v("-- seen_txid   "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# HDFS 格式化后为 0，记录 edits 文件尾数")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token variable"}},[a._v("`")])]),a._v("-- in_use.lock     "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 用于控制 NameNode 启动的一把锁，存在则已启动，不可重启，不存在则已停止")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br")])]),s("ul",[s("li",[a._v("FsImage：元数据镜像文件，持久化元数据信息（快照），包含整个命名空间的信息及文件数据块的映射信息等")]),a._v(" "),s("li",[a._v("EditLog：事务日志文件，记录每一个对文件系统元数据的改变")])]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# -i：输入，-o：输出")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 查看 fsimage 文件")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("root@xzx-hadoop namenode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# hdfs oiv -p XML -i current/fsimage_0000000000000000016 -o fsimage16.xml")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 查看 edits 文件")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("root@xzx-hadoop namenode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# hdfs oev -i current/edits_0000000000000000009-0000000000000000010 -o edits.xml")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("blockquote",[s("p",[a._v("hdfs-default.xml：位于 $HADOOP_HOME\\share\\hadoop\\hdfs\\hadoop-hdfs-xxx.jar，配置 HDFS 所有默认参数，hdfs-site.xml 属于该文件一个扩展，可覆盖默认参数")])]),a._v(" "),s("p",[a._v("NameNode 元数据信息维护了两个关系映射：")]),a._v(" "),s("ul",[s("li",[a._v("File 与 Block List 的映射关系")]),a._v(" "),s("li",[a._v("DataNode 与 Block 的映射关系")])]),a._v(" "),s("blockquote",[s("p",[a._v("NameNode 启动时会将文件元数据信息加载至内存中，每个文件元数据信息占用固定的 150 字节空间。HDFS 不适合存储小文件，因为 NameNode 的内存占满后，DataNode 存储了大量小文件，但文件总体大小很小，失去 HDFS 的价值。")])]),a._v(" "),s("p",[a._v("首次启动 NameNode：")]),a._v(" "),s("ol",[s("li",[a._v("格式化文件系统，生成 FsImage 元数据镜像文件；")]),a._v(" "),s("li",[a._v("启动 NameNode：读取 FsImage 文件并加载进内存；等待 DataNade 注册并发送块状态报告（block report）")]),a._v(" "),s("li",[a._v("启动 DataNode：向 NameNode 注册并发送块状态报告；检查 FsImage 中记录的块数量和块状态报告中的块的总数是否相同")])]),a._v(" "),s("p",[a._v("第二次启动 NameNode：读取 Fsimage/Editlog 文件并合并成新的 FsImage 文件；创建新的 EditLog 文件，内容开始为空；启动 DataNode")]),a._v(" "),s("h2",{attrs:{id:"secondarynamenode"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#secondarynamenode"}},[a._v("#")]),a._v(" SecondaryNameNode")]),a._v(" "),s("p",[a._v("SecondaryNamenode：完成 NameNode CheckPoint（检查点）工作，减少 Editlog 文件大小，缩短 NameNode 重启时间。")]),a._v(" "),s("p",[a._v("NameNode CheckPoint：只有当 NameNode 启动时，才会从磁盘中读取 FsImage/EditLog，将 EditLog 中的所有事务应用合并到 FsImage（得到最新的文件系统镜像快照），然后将新的 FsImage 刷新到本地磁盘中，再删除旧的 EditLog 并创建新的 EditLog。\n"),s("img",{attrs:{src:"/images/kr/bigdata/hadoop/SecondaryNamenode-CheckPoint.jpg",alt:""}})]),a._v(" "),s("p",[a._v("日志与镜像的定期合并步骤：")]),a._v(" "),s("ul",[s("li",[a._v("SecondaryNameNode 请求 NameNode 执行检查点，此时 NameNode 产生 edits.new")]),a._v(" "),s("li",[a._v("SecondaryNameNode 通过 HTTP GET 获取 NameNode 的 FsImage/Editlog")]),a._v(" "),s("li",[a._v("SecondaryNameNode 开始合并 FsImage/Editlog，产生新的 fsimage.ckpt 文件")]),a._v(" "),s("li",[a._v("SecondaryNameNode 通过 HTTP POST 发送 fsimage.ckpt 至 NameNode")]),a._v(" "),s("li",[a._v("NameNode 将 fsimage.ckpt/edits.new 分别重命名为 fsimage/edits，然后刷新 FsImage 到磁盘")])]),a._v(" "),s("blockquote",[s("p",[a._v("在 NameNode 的 HA 架构中没有 SecondaryNameNode 进程，检查点工作会由 StandbyNameNode 负责实现，故 Hadoop 集群中，SecondaryNameNode 进程并不是必须的")])]),a._v(" "),s("blockquote",[s("p",[a._v("NameNode 中元数据丢失，可从 SecondaryNameNode 恢复一部分，但不能恢复全部，因 NameNode 正在写的 EditLog 日志还没有拷贝到 SecondaryNameNode。")]),a._v(" "),s("p",[a._v("SecondaryNameNode 不能恢复 NameNode 的全部元数据，那如何保证 NameNode 元数据存储安全？：NameNode HA 高可用")])]),a._v(" "),s("h2",{attrs:{id:"datanode"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#datanode"}},[a._v("#")]),a._v(" DataNode")]),a._v(" "),s("p",[a._v("DataNode 文件存储服务：")]),a._v(" "),s("ul",[s("li",[a._v("Block：数据读写基本单元，按照固定大小、顺序进行文件分块，默认 Block 大小为 128 M")]),a._v(" "),s("li",[a._v("DataNode 中文件路径由 hdfs-default.xml 中 dfs.datanode.data.dir 配置")]),a._v(" "),s("li",[a._v("HDFS 中，若一个文件小于一个数据块大小，那么并不会占用整个数据块的存储空间")]),a._v(" "),s("li",[a._v("数据块存在多副本机制，保证数据安全，由 dfs.replication 配置，默认 3 个副本")]),a._v(" "),s("li",[a._v("数据完整性：读取块时，计算数据块校验和，若与块创建时校验和不一样，则该块已损坏，这时应该读取块副本")])]),a._v(" "),s("p",[a._v("NameNode 周期性从 DataNode 接收心跳信号和块状态报告：")]),a._v(" "),s("ul",[s("li",[a._v("心跳信号：意味着该 Datanode 节点工作正常")]),a._v(" "),s("li",[a._v("块状态报告：包含了该 Datanode 节点信息及其上所有数据块的列表等信息")])]),a._v(" "),s("blockquote",[s("p",[a._v("块状态报告：集群启动时，DataNode 会扫描该节点上所有 Block 信息，再将节点及其上的 Block 信息发送至 NameNode，这个过程在集群启动时进行动态加载，故集群数据越多，启动越慢。")])]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# DataNode 的目录结构是初始阶段自动创建，查看版本号")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("root@dmcdw-1 current"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# cat /usr/local/data/hadoop/datanode/current/VERSION")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#Fri Oct 08 11:02:02 CST 2021")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("storageID")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("DS-d81c0a18-2a58-41a1-9f67-997b4346d0c7\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 存储ID")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("clusterID")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("CID-9eff8e06-885a-47b5-955e-7afc04474768\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 集群ID，全局唯一")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("cTime")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# DataNode 存储系统创建时间，是在文件系统升级之后，该值会更新到新的时间戳")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("datanodeUuid")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("d83dfcb7-c1aa-4aeb-a88b-9cb008d2af85\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# DataNode 的唯一识别码")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("storageType")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("DATA_NODE "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 存储类型")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("layoutVersion")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("-57 "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 负整数，通常只有 HDFS 增加新特性时才会更新这个值")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br")])]),s("h2",{attrs:{id:"hdfs-high-available-ha-高可用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hdfs-high-available-ha-高可用"}},[a._v("#")]),a._v(" HDFS High Available（HA） 高可用")]),a._v(" "),s("p",[a._v("NameNode 单点故障：NameNode 负责接收用户的操作请求，当只有一个 NameNode 时，存在 NameNode 宕机无法提供服务及元数据丢失无法恢复的单点故障。\n"),s("img",{attrs:{src:"/images/kr/bigdata/hadoop/HDFS-HA.bmp",alt:""}})]),a._v(" "),s("ul",[s("li",[a._v("Active NN：集群中任意时刻，只有一个 Active NN，负责客户端请求操作服务")]),a._v(" "),s("li",[a._v("Standby NN：用来同步 Active NN 的状态信息，以提供快速的故障恢复能力（热备份）")]),a._v(" "),s("li",[a._v("JournalNodes（JN）：保证 Active NN 和 Standby NN 节点状态同步，即元数据一致\n"),s("ul",[s("li",[a._v("通过一组独立的轻量级守护进程 JournalNodes（JN）同步 Editlog 信息")]),a._v(" "),s("li",[a._v("当 Active NN 执行任何有关命名空间的修改，它需要持久化到一半 JN 以上")]),a._v(" "),s("li",[a._v("而 Standby NN 负责读取从 JN 上发送过来的 Editlog 信息，并更新自己内部的命名空间")]),a._v(" "),s("li",[a._v("当 Active NN 不可用，Standby NN 需保证从 JN 中读出全部 Editlog，再切换成 Active 状态")]),a._v(" "),s("li",[a._v("如果有多个 Standby NN，则通过 Zookeeper 集群选举操作，选择一个切换为 Active 状态")])])])]),a._v(" "),s("p",[a._v("元数据同步（采用共享存储，即 JN）：")]),a._v(" "),s("ul",[s("li",[a._v("静态：由于 FsImage 是由 Editlog 合并生成的，所以只需要保证多个 NameNode 中 Editlog 内容的事务性同步，由 JournalNodes 集群进行同步")]),a._v(" "),s("li",[a._v("动态：DataNode 上报数据块信息时需要向每个 NameNode 都上报一份，保证多个 NameNode 的元数据信息一致")])]),a._v(" "),s("p",[a._v("HDFS HA 集群配置：")]),a._v(" "),s("ul",[s("li",[a._v("NameNode：Active NN 和 Standby NN 的机器应保持一致")]),a._v(" "),s("li",[a._v("通过 Zookeeper 集群进行 NameNode 失败检测和 NameNode 选举，实现自动故障转移")]),a._v(" "),s("li",[a._v("JournalNodes：通常部署奇数(N)个 JN 节点，则可容纳(N-1)/2个节点故障但不影响集群运行")])]),a._v(" "),s("blockquote",[s("p",[a._v("HA 集群不部署 SecondaryNameNode，SecondaryNameNode 检查点工作由 Standby NN 负责")])]),a._v(" "),s("h3",{attrs:{id:"namenode-元数据共享存储方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#namenode-元数据共享存储方案"}},[a._v("#")]),a._v(" NameNode 元数据共享存储方案")]),a._v(" "),s("p",[a._v("基于 QJM 的共享存储主要用于保存 EditLog 并不保存 FsImage，FsImage 还是在 NameNode 的本地磁盘上")]),a._v(" "),s("p",[a._v("QJM 共享存储的基本思想来自于 Paxos 算法，采用多个称为 JournalNode 的节点组成 JournalNode 集群来存储 EditLog。每个 JournalNode 保存同样的 EditLog 副本。每次 NameNode 写 EditLog 时，除了向本地磁盘写入 EditLog 之外，也会并行地向 JournalNode 集群之中的每一个 JournalNode 发送写请求，只要过半 JournalNode 节点返回成功就认为向 JournalNode 集群写入 EditLog 成功。")]),a._v(" "),s("h3",{attrs:{id:"脑裂问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#脑裂问题"}},[a._v("#")]),a._v(" 脑裂问题")]),a._v(" "),s("p",[a._v("脑裂：当 Zookeeper 与 Active NameNode 间由于某些原因（网络断开）造成心跳检测失败，ZK 认为该 NameNode 不可用，故从 Standby NameNode 中选举一个作为 Active NmaeNode，此时原先 NameNode 仍可能处于 Active 状态，这时集群中存在两个 Active NameNode，会造成数据不一致且无法恢复。\nZK 解决方案：隔离（fencing）原先的 Active NaemNode，使其不能对外提供服务：")]),a._v(" "),s("ol",[s("li",[a._v("首先尝试调用这个 Active NameNode 的 HAServiceProtocol RPC 接口的 transitionToStandby 方法，看能不能把它转换为 Standby 状态")]),a._v(" "),s("li",[a._v("如果 transitionToStandby 方法调用失败，那么就执行 Hadoop 配置文件中预定义的隔离措施，Hadoop 目前主要提供两种隔离措施，通常会选择 sshfence：\n"),s("ul",[s("li",[a._v("sshfence：通过 SSH 登录到目标机器上，执行命令 fuser 将对应的进程杀死")]),a._v(" "),s("li",[a._v("shellfence：执行一个用户自定义的 shell 脚本来将对应的进程隔离")])])])]),a._v(" "),s("h2",{attrs:{id:"hdfs-federation-高扩展"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hdfs-federation-高扩展"}},[a._v("#")]),a._v(" HDFS Federation 高扩展")]),a._v(" "),s("p",[a._v("HDFS Federation 允许一个 HDFS 集群中存在多个 NameNode 同时对外提供服务，可以解决单一命名空间存在的问题，每个 NameNode 负责一个命名空间，彼此之间相互隔离独立，但共享底层 DataNode 存储资源，特性：\n"),s("img",{attrs:{src:"/images/kr/bigdata/hadoop/HDFS-Federation.bmp",alt:""}})]),a._v(" "),s("ul",[s("li",[a._v("集群扩展性：多个 NameNode 分管不同命名空间，集群易扩展，不因内存限制制约文件存储数目")]),a._v(" "),s("li",[a._v("性能更高效：多个 NameNode 管理不同数据，且同时对外提供服务，提高读写吞吐率")]),a._v(" "),s("li",[a._v("良好隔离性：可根据需要将不同业务数据交由不同 NameNode 管理，这样不同业务之间影响很小")]),a._v(" "),s("li",[a._v("DataNode 向所有 NameNode 发送心跳信号和块状态报告，同时执行所有 NameNode 的命令")])]),a._v(" "),s("h2",{attrs:{id:"hdfs-文件读写流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hdfs-文件读写流程"}},[a._v("#")]),a._v(" HDFS 文件读写流程")]),a._v(" "),s("p",[a._v("图片引用："),s("a",{attrs:{href:"http://km.ciozj.com/Detail.aspx?AI=93617&CI=218",target:"_blank",rel:"noopener noreferrer"}},[a._v("http://km.ciozj.com/Detail.aspx?AI=93617&CI=218"),s("OutboundLink")],1)]),a._v(" "),s("h3",{attrs:{id:"hdfs-读流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hdfs-读流程"}},[a._v("#")]),a._v(" HDFS 读流程")]),a._v(" "),s("p",[s("img",{attrs:{src:"/images/kr/bigdata/hadoop/HDFS-%E8%AF%BB%E6%B5%81%E7%A8%8B.png",alt:""}})]),a._v(" "),s("ol",[s("li",[a._v("打开文件：HDFS 客户端调用 DistributedFileSystem.open()，向 NameNode 发送 RPC 请求，请求数据块位置")]),a._v(" "),s("li",[a._v("读取数据块信息：NameNode 进行权限及文件是否存在校验，校验通过后会返回部分/全部块列表，其中包含每个数据块及其副本的 DataNode 地址\n"),s("ul",[s("li",[a._v("按照集群拓补结构得出 DataNode 与客户端的距离，按规则排序：")]),a._v(" "),s("li",[a._v("群拓补结构中距离客户端近的靠前；心跳机制中超时汇报的 DataNode 状态为 STALE，靠后")])])]),a._v(" "),s("li",[a._v("读取块数据：客户端调用 FSDatatInputStream.read()，按照每个 DataNode 的距离从近到远依次读取\n"),s("ul",[s("li",[a._v("短路读取特性：若客户端本身就是 DataNode，那么将从本地直接获取数据")])])]),a._v(" "),s("li",[a._v("读取完一个块都会进行数据块校验和（checksum）验证：若读取 DataNode 时出现错误（/读取到本地的块与 HDFS 上的原始块进行校验，校验结果不一致），客户端会通知 NameNode，然后再从下一个拥有该 block 副本的 DataNode 继续读")]),a._v(" "),s("li",[a._v("当读完块列表后，若文件读取还没有结束，客户端会继续向 NameNode 获取下一批 block 列表，重复2，3，4")]),a._v(" "),s("li",[a._v("最终读取来所有的 block 会合并成一个完整的最终文件，调用 FsDataInputStream.close() 关闭文件")])]),a._v(" "),s("h3",{attrs:{id:"hdfs-写流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hdfs-写流程"}},[a._v("#")]),a._v(" HDFS 写流程")]),a._v(" "),s("p",[s("img",{attrs:{src:"/images/kr/bigdata/hadoop/HDFS-%E5%86%99%E6%B5%81%E7%A8%8B.png",alt:""}})]),a._v(" "),s("ol",[s("li",[a._v("创建文件：HDFS 客户端调用 DistributedFileSystem.create()，向 NameNode 发送 RPC 请求，请求创建新文件")]),a._v(" "),s("li",[a._v("创建文件元数据：NameNode 进行权限及文件重名校验，校验通过后在命名空间创建一个新文件，并返回可上传信息")]),a._v(" "),s("li",[a._v("写入数据块：流水线复制方式，客户端将文件分片，放入一个队列中，依次向 NameNode 申请数据块保存的 DataNode 节点\n"),s("ul",[s("li",[a._v("NameNode 根据网络拓扑和机架感知以及副本机制进行文件分配，返回可用的 DataNode 地址")]),a._v(" "),s("li",[a._v("客户端将 DataNode 节点组成数据流管道，数据块（数据包为单位）发送到第一个节点，第一个节点再发送给第二个节点，依次类推")])])]),a._v(" "),s("li",[a._v("接收确认：当最后一个 DataNode 写好数据块后，就会返回一个确认包。最后一个数据节点发送给最后第二个数据节点以此类推，传回到第一个数据节点，再传回到客户端")]),a._v(" "),s("li",[a._v("当一个块传输完成后, 客户端再次请求 NameNode 上传第二个块，重复3，4")]),a._v(" "),s("li",[a._v("管道中所有的 DataNode 都保存完成后，调用 FileSystem.close() 关闭数据流")])]),a._v(" "),s("blockquote",[s("p",[a._v("客户端上传文件时与 DataNode 建立数据流管道，管道的正方向是客户端向 DataNode 发送的数据包，管道反向是 DataNode 向客户端发送 Ack 确认应答。\n当 DataNode 突然挂掉了，客户端接收不到这个 DataNode 发送的 Ack 确认，客户端会通知 NameNode，NameNode 检查该块的副本与规定的不符，NameNode 会通知 DataNode 去复制副本，并将挂掉的 DataNode 作下线处理，不再让它参与文件上传与下载")])]),a._v(" "),s("blockquote",[s("p",[a._v("注：HDFS 文件写入时是串行写入，数据包按数据流管道依次发送给 DataNode；而 HDFS 文件读取是并行读取块所在的节点。")]),a._v(" "),s("p",[a._v("扩展：网络拓补结构中的节点距离概念：两个节点到达最近的共同祖先的距离总和，以带宽作为距离的衡量标准")])]),a._v(" "),s("h2",{attrs:{id:"hdfs-多副本机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hdfs-多副本机制"}},[a._v("#")]),a._v(" HDFS 多副本机制")]),a._v(" "),s("p",[a._v("文件存储成一系列数据块，数据块大小：Hadoop 1.0 默认为 64MB，Hadoop 2.0/3.0 默认为 128MB；通过副本冗余容错机制来保证数据的高可靠，文件的所有数据块都会有副本。\n副本的存放是 HDFS 可靠性和性能的关键，副本存放策略：HDFS 采用一种称为"),s("code",[a._v("机架感知")]),a._v("(rack-aware)的策略来改进数据的可靠性、可用性和网络带宽的利用率。")]),a._v(" "),s("p",[a._v("HDFS 机架感知存放策略：将一个副本存放在本地机架的节点上，一个副本存放在同一机架的另一个节点上，最后一个副本存放在不同机架的节点上。（副本系数默认为 3）")]),a._v(" "),s("blockquote",[s("p",[a._v("副本并不是均匀分布在不同的机架上，而是三分之一的副本在一个节点上，三分之二的副本在一个机架上，这一策略在不损害数据可靠性和读取性能的情况下改进了写的性能。\n为了降低整体的带宽消耗和读取延时，HDFS会尽量让读取程序读取离它最近的副本。")])]),a._v(" "),s("h2",{attrs:{id:"hdfs-数据组织"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hdfs-数据组织"}},[a._v("#")]),a._v(" HDFS 数据组织")]),a._v(" "),s("ul",[s("li",[a._v("数据块存储：文件分块写入，一次写入、多次读取")]),a._v(" "),s("li",[a._v("流水线复制：数据以流水线的方式从前一个 DataNode 复制到下一个 DataNode")]),a._v(" "),s("li",[a._v("文件回收站：回收站目录 /trash，HDFS 会自动删除回收站中的保留时间超过 6 小时的文件")])]),a._v(" "),s("blockquote",[s("p",[a._v("文件分块：一个节点无法存储超大文件；网络传输时万一宕掉，可以小部分重传；简化了存储管理，同时元数据就不需要和块一同存储了，用一个单独的系统就可以管理这些块的元数据，所以块是 HDFS 中最基本的存储单位。")])]),a._v(" "),s("h2",{attrs:{id:"hdfs-回收站"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hdfs-回收站"}},[a._v("#")]),a._v(" HDFS 回收站")]),a._v(" "),s("p",[a._v("HDFS 为每个用户创建一个回收站目录：/user/用户名/.Trash/，回收站默认不开启，其中文件目录有生存周期，开启配置：")]),a._v(" "),s("div",{staticClass:"language-bash core-site.xml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("property"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("name"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("fs.trash.interval"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("/name"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("value"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("144")]),s("span",{pre:!0,attrs:{class:"token operator"}},[s("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[a._v("0")]),a._v("<")]),a._v("/value"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("     "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 生存周期，单位分钟")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("/property"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("blockquote",[s("p",[a._v("若删除文件超过回收站大小，则提示删除失败，需通过参数 -skipTrash 指示删除文件不会进回收站")])]),a._v(" "),s("h2",{attrs:{id:"hdfs-文件限额"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hdfs-文件限额"}},[a._v("#")]),a._v(" HDFS 文件限额")]),a._v(" "),s("p",[a._v("HDFS 文件的限额配置允许以文件个数，或者文件大小来限制在某个目录下上传的文件数量或者文件内容总量。")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("hdfs dfs -count -q -h /user/root/dir1\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 查看配额信息")]),a._v("\nhdfs dfsadmin -setQuota "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("dir")]),a._v(" \t\t\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 文件数量限额：给该文件夹下面设置最多上传两个文件")]),a._v("\nhdfs dfsadmin -clrQuota /user/root/dir \t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 清除文件数量限额")]),a._v("\nhdfs dfsadmin -setSpaceQuota 4k /user/root/dir \t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 空间大小限额：限制空间大小4KB")]),a._v("\nhdfs dfsadmin -clrSpaceQuota /user/root/dir \t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 清除空间大小限额")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("h2",{attrs:{id:"hdfs-安全模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hdfs-安全模式"}},[a._v("#")]),a._v(" HDFS 安全模式")]),a._v(" "),s("p",[a._v("在集群启动时，HDFS 都会检查集群中文件信息是否完整，该时间段内是不允许对集群有修改操作的，等 HDFS 自检完毕，就会自动退出安全模式。\n举例：在三副本机制下，在 DataNode 上就应该有三副本存在，假设只存在两个副本，则副本率为 2/3=0.666，小于默认副本率 0.999，因此系统会自动的复制副本到其他 DataNode，使得副本率不小于 0.999；如果系统中有五副本，超过三副本，那么系统也会删除多余的两个副本。")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("root@xzx-hadoop-master /"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# hdfs dfsadmin -safemode get     # 查看当前安全模式状态")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("root@xzx-hadoop-master /"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# hdfs dfsadmin -safemode leave   # 强制退出安全模式")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("root@xzx-hadoop-master /"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# hdfs dfsadmin -safemode enter   # 手动进入安全模式")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("h2",{attrs:{id:"hdfs-健壮性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hdfs-健壮性"}},[a._v("#")]),a._v(" HDFS 健壮性")]),a._v(" "),s("p",[a._v("HDFS 主要目标是即使在出错的情况下也要保证数据存储的可靠性；HDFS 提供多种错误恢复手段，保障了系统的健壮性。")]),a._v(" "),s("ul",[s("li",[a._v("心跳检测：NameNode 检测 DataNaode 的状态")]),a._v(" "),s("li",[a._v("副本重新复制：NameNode 检测数据块副本数，若低于指定值，则启动副本复制操作")]),a._v(" "),s("li",[a._v("集群均衡： HDFS 架构支持数据均衡策略")]),a._v(" "),s("li",[a._v("数据完整性：通过校验和(checkSum)检查，当创建新文件时，会计算文件每个数据块的校验和，并将校验和作为一个单独的隐藏文件保存在同一个 HDFS 名字空间下")]),a._v(" "),s("li",[a._v("元数据磁盘错误：NameNode 可以配置成支持维护多个 FsImage/Editlog 的副本")]),a._v(" "),s("li",[a._v("快照：支持某一特定时刻的数据的复制备份")])])])}),[],!1,null,null,null);e.default=r.exports}}]);